{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/logo.jpg","path":"img/logo.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1494120223099},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1494120223099},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1494120223099},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1494120223099},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1494120223099},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1494120223099},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1494120223099},{"_id":"themes/yilia/_config.yml","hash":"9bbd6d6c0448e68c138ccd98779e702938be49fa","modified":1494142528349},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1494120223139},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1494120223107},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"891805485d22f9cbd7a1042d98f7953414f4c0fd","modified":1494121508418},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"8f4a22eb786c9e9bbdc102cb29a642ac853a224d","modified":1494121508241},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1494120218522},{"_id":"themes/yilia/.git/config","hash":"45dbf7cad960774e3ebd63f878005463a78e4c69","modified":1494120218550},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1494118823551},{"_id":"themes/yilia/.git/packed-refs","hash":"a8140137954dec646b34af234b44895c240f8f38","modified":1494120218502},{"_id":"themes/yilia/.git/index","hash":"dfc86c63a0717854f7b0125894bc14471ec16b5f","modified":1494120223139},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1494120223131},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1494120223107},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1494120223139},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1494120223099},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1494120223099},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1494120223099},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1494120223127},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1494120223099},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1494120223099},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1494120223099},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1494120223099},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1494120223103},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1494120223103},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1494120223103},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1494120223107},{"_id":"source/_posts/debug/debug.md","hash":"4099050c0d3aabf2cd9e2168157101c272d90f12","modified":1495820332319},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1494120223103},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1494120223103},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1494120223103},{"_id":"source/_posts/null-character/index.md","hash":"f49711ea7b19dc6e3e11bfd976c35cd766bcaef3","modified":1496056970846},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1494120223135},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1494120223131},{"_id":"source/_posts/programme-exercise/index.md","hash":"f051e564d75db8b903deadbaf7aec6a660538442","modified":1495819026569},{"_id":"source/_posts/tail-recursion/index.md","hash":"1acfc519b8eef224c8431374594061f458f05f86","modified":1496057654504},{"_id":"source/_posts/gets-s/gets_s.md","hash":"664510d8ccef788eeb4f8d0762196415368d675a","modified":1496057135336},{"_id":"themes/yilia/.git/logs/HEAD","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218550},{"_id":"source/_posts/hello-world/hello-world.md","hash":"99fd04976870fb1e4add8f7fae8537847776ddf3","modified":1496055451639},{"_id":"source/_posts/hello-byxc/hello-byxc.md","hash":"eea932dfd100463ac83369591ce616b9f3561f92","modified":1495817087781},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1494118823551},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1494120223127},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1494118823551},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1494120223131},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1494120223131},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1494120223131},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1494118823551},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1494120223131},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1494120223131},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1494120223107},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1494120223107},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1494120223107},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1494120223111},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1494120223119},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1494120223107},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1494120223119},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1494120223119},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1494120223119},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1494120223119},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1494120223119},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1494120223119},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1494120223119},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1494120223119},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1494120223123},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1494120223131},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1494120223131},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1494120223119},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1494120223127},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1494120223127},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1494120223127},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1494120223127},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1494120223127},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1494120223127},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1494120223123},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1494120223127},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1494120223127},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1494120223127},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1494120223099},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1494120223127},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1494120223103},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1494120223131},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1494120223103},{"_id":"themes/yilia/.git/refs/heads/master","hash":"891805485d22f9cbd7a1042d98f7953414f4c0fd","modified":1494120218550},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1494120223111},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1494120223119},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"1ba1d4a4663eae37b1a2b75c47dfdff4fb3cbf52","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"7851d961ae172f521ba71e255fdc60f4ca0b45ed","modified":1494120223103},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1494120223119},{"_id":"themes/yilia/.git/objects/pack/pack-34ce1806cd91d51f5b1d1f827d0021b0fcdfc362.idx","hash":"98ba278b2bd2a0baf4c76325542a2c9922d7cd45","modified":1494120217721},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1494120223119},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1494120223119},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218550},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1494120218522},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218522},{"_id":"themes/yilia/source/img/logo.jpg","hash":"2a36910bbd0adf836ae5e7e89fb04ddfb82e540f","modified":1494123827891},{"_id":"themes/yilia/.git/objects/pack/pack-34ce1806cd91d51f5b1d1f827d0021b0fcdfc362.pack","hash":"023b4f59fd0e9f9fe92edb89711489870a07d85a","modified":1494120217697}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"debug","date":"2017-05-26T17:33:41.000Z","_content":"\n在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。\n但预览功能还是挺好的\n","source":"_posts/debug/debug.md","raw":"---\ntitle: debug\ndate: 2017-05-27 01:33:41\ntags: 随笔\n---\n\n在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。\n但预览功能还是挺好的\n","slug":"debug/debug","published":1,"updated":"2017-05-26T17:38:52.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu280000mqlwg3hfbfz5","content":"<p>在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。<br>但预览功能还是挺好的</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。<br>但预览功能还是挺好的</p>\n"},{"title":"字符串和空字符","date":"2017-05-29T09:52:12.000Z","_content":"\n## 提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\n\n<!--more-->\n\n然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 `\\0` 的 bug 。\n\n``` c\n\t/* File: reverse.c\n\t * Author: ByXc\n\t * About: reverse\n\t * Version: 1.0\n\t * Compilation: gcc 5.3.0 for MinGw\n\t * Date: 20170513\n\t * Github: ByXc01\n\t * Blog: http://ByXc01.github.io\n\t */\n\n\t#include <stdio.h>\n\t#include <string.h>\n\n\tint main(void)\n\t{\n\t\tint i_count;\n\t\tchar ch_string[40];\n\n\t\tprintf(\"Please enter a string:\");\n\t\tscanf(\"%s\", ch_string);\n\t\n\t\tfor (i_count = strlen(ch_string); i_count >= 0; i_count--)\n\t\t    printf(\"%c\", ch_string[i_count - 1]);        //i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)\n\t\tprintf(\"\\nThe all! \");\n\n\t\treturn 0;\n\t}\n\t\n    /* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，\n     * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。\n     * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1\n     */\n\n```\n\n這個程序很簡單， 是 《*c primer plus*》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 `i_count - 1`， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 **“空格”**， 輸出如下：\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_string.png \"空字符\")\n\n**後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ `if (*(ch_string + 4) == ' ')` 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):**\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_string2.png \"空字符\")\n\n因為折騰的蠻久的， 印象也特別深刻。\n\n## 接著在第十一章又見空字符\n\n```c\n\tchar cha_string1[] = { 'B', 'y', 'X', 'c', '\\0' };\n\tchar cha_string2[] = { \"ByXc\" };\n\tchar * chp_string3 = { \"ByXc\" };\n\tchar * chp_string4 = \"ByXc\";\n\tchar cha_string3[5];\n\n\tcha_string[0] = 'B', \n\tcha_string[1] = 'y', \n\tcha_string[2] = 'X', \n\tcha_string[3] = 'c';\n```\n\n以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。\n\n**所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)**\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_strin3.png \"空字符\")\n\n讓我感覺想不通的還是程序清單 11.13 的輸出:\n\n```c\n\t/* nono.c -- 千萬不要模仿 */\n\t#include <stdio.h>\n\tint main(void)\n\t{\n\t\tchar side_a[] = \"Side A\";\n\t\tchar dont[] = { 'W', 'O', 'W', '!' };\n\t\tchar side_b[] = \"Side B\";\n\t\tputs(dont);\t\t// dont 不是一個字符串， 應是一個字符數組\n\n\t\treturn 0;\n\t}\n```\n\n由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：\n\n```c\n\tWOW!Side A\n```\n\n**我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。**\n\n***\n\n然而我的輸出為：\n\n```\n\tWOW!\n```\n\n然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 `gcc -S` 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。\n\n![沒有自動添加空字符啊](http://opkl2tvjd.bkt.clouddn.com/character_array.png \"沒有自動添加空字符啊\")\n\n可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:\n\n![clang](http://opkl2tvjd.bkt.clouddn.com/null_string4.png \"clang\")\n\n用 `clang -S` 編譯出來的彙編如下：\n\n``` \n\t\t.text\n\t\t.file\t\"nono.c\"\n\t\t.globl\tmain\n\t\t.align\t16, 0x90\n\t\t.type\tmain,@function\n\tmain:                                   # @main\n\t\t.cfi_startproc\n\t# BB#0:\n\t\tpushq\t%rbp\n\t.Ltmp0:\n\t\t.cfi_def_cfa_offset 16\n\t.Ltmp1:\n\t\t.cfi_offset %rbp, -16\n\t\tmovq\t%rsp, %rbp\n\t.Ltmp2:\n\t\t.cfi_def_cfa_register %rbp\n\t\tsubq\t$32, %rsp\n\t\tleaq\t-15(%rbp), %rdi\n\t\tmovl\t$0, -4(%rbp)\n\t\tmovl\t.Lmain.side_a, %eax\n\t\tmovl\t%eax, -11(%rbp)\n\t\tmovw\t.Lmain.side_a+4, %cx\n\t\tmovw\t%cx, -7(%rbp)\n\t\tmovb\t.Lmain.side_a+6, %dl\n\t\tmovb\t%dl, -5(%rbp)\n\t\tmovl\t.Lmain.dont, %eax\n\t\tmovl\t%eax, -15(%rbp)\n\t\tmovl\t.Lmain.sidw_b, %eax\n\t\tmovl\t%eax, -22(%rbp)\n\t\tmovw\t.Lmain.sidw_b+4, %cx\n\t\tmovw\t%cx, -18(%rbp)\n\t\tmovb\t.Lmain.sidw_b+6, %dl\n\t\tmovb\t%dl, -16(%rbp)\n\t\tcallq\tputs\n\t\txorl\t%esi, %esi\n\t\tmovl\t%eax, -28(%rbp)         # 4-byte Spill\n\t\tmovl\t%esi, %eax\n\t\taddq\t$32, %rsp\n\t\tpopq\t%rbp\n\t\tretq\n    .Lfunc_end0:\n\t\t.size\tmain, .Lfunc_end0-main\n\t\t.cfi_endproc\n\n        .type   .Lmian.side_a,@object   # @main.side_a\n\t\t.section\t    .rodata.str1.1,\"aMS\",@progbits,1\n\n\t.Lmain.side_a:\n\t\t.asciz\t\"Side A\"\n\t\t.size\t.Lmain.side_a, 7\n\n\t\t.type\t.Lmain.dont,@object     # @main.dont\n\t\t.section\t.rodata.cst4,\"aM\",@progbits,4\n\t.Lmain.dont:\n\t\t.ascii\t\"WOW!\"\n\t\t.size\t.Lmain.dont, 4\n\n\t\t.type\t.Lmain.sidw_b,@object   # @main.sidw_b\n\t\t.section\t.rodata.str1.1,\"aMS\",@progbits,1\n\t.Lmain.sidw_b:\n\t\t.asciz\t\"Sdie B\"\n\t\t.size\t.Lmain.sidw_b, 7\n\n\n\t\t.ident\t\"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)\"\n\t\t.section\t\".note.GNU-stack\",\"\",@progbits\n```\n同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：\n\n```\n\t.Lmain.dont:\n\t\t.ascii\t\"WOW!\"\n\t\t.size\t.Lmain.dont, 4\n```\n\nsize 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。\n在 c 代碼總也可用 `sizeof` 來檢測是否有空字符:\n\n```c\n\tprintf(\"side_a: sizeof = %zd, strlen = %zd \\n\", sizeof （side_a), strlen(side_a));\n\tprintf(\"dont: sizeof = %zd, strlen = %zd \\n\", sizeof (dont), strlen(dont));\n\t// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符\n```\n\n反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。\n","source":"_posts/null-character/index.md","raw":"---\ntitle: 字符串和空字符\ndate: 2017-05-29 17:52:12\ntags: 空字符\n---\n\n## 提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\n\n<!--more-->\n\n然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 `\\0` 的 bug 。\n\n``` c\n\t/* File: reverse.c\n\t * Author: ByXc\n\t * About: reverse\n\t * Version: 1.0\n\t * Compilation: gcc 5.3.0 for MinGw\n\t * Date: 20170513\n\t * Github: ByXc01\n\t * Blog: http://ByXc01.github.io\n\t */\n\n\t#include <stdio.h>\n\t#include <string.h>\n\n\tint main(void)\n\t{\n\t\tint i_count;\n\t\tchar ch_string[40];\n\n\t\tprintf(\"Please enter a string:\");\n\t\tscanf(\"%s\", ch_string);\n\t\n\t\tfor (i_count = strlen(ch_string); i_count >= 0; i_count--)\n\t\t    printf(\"%c\", ch_string[i_count - 1]);        //i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)\n\t\tprintf(\"\\nThe all! \");\n\n\t\treturn 0;\n\t}\n\t\n    /* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，\n     * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。\n     * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1\n     */\n\n```\n\n這個程序很簡單， 是 《*c primer plus*》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 `i_count - 1`， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 **“空格”**， 輸出如下：\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_string.png \"空字符\")\n\n**後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ `if (*(ch_string + 4) == ' ')` 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):**\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_string2.png \"空字符\")\n\n因為折騰的蠻久的， 印象也特別深刻。\n\n## 接著在第十一章又見空字符\n\n```c\n\tchar cha_string1[] = { 'B', 'y', 'X', 'c', '\\0' };\n\tchar cha_string2[] = { \"ByXc\" };\n\tchar * chp_string3 = { \"ByXc\" };\n\tchar * chp_string4 = \"ByXc\";\n\tchar cha_string3[5];\n\n\tcha_string[0] = 'B', \n\tcha_string[1] = 'y', \n\tcha_string[2] = 'X', \n\tcha_string[3] = 'c';\n```\n\n以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。\n\n**所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)**\n\n![空字符](http://opkl2tvjd.bkt.clouddn.com/null_strin3.png \"空字符\")\n\n讓我感覺想不通的還是程序清單 11.13 的輸出:\n\n```c\n\t/* nono.c -- 千萬不要模仿 */\n\t#include <stdio.h>\n\tint main(void)\n\t{\n\t\tchar side_a[] = \"Side A\";\n\t\tchar dont[] = { 'W', 'O', 'W', '!' };\n\t\tchar side_b[] = \"Side B\";\n\t\tputs(dont);\t\t// dont 不是一個字符串， 應是一個字符數組\n\n\t\treturn 0;\n\t}\n```\n\n由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：\n\n```c\n\tWOW!Side A\n```\n\n**我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。**\n\n***\n\n然而我的輸出為：\n\n```\n\tWOW!\n```\n\n然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 `gcc -S` 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。\n\n![沒有自動添加空字符啊](http://opkl2tvjd.bkt.clouddn.com/character_array.png \"沒有自動添加空字符啊\")\n\n可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:\n\n![clang](http://opkl2tvjd.bkt.clouddn.com/null_string4.png \"clang\")\n\n用 `clang -S` 編譯出來的彙編如下：\n\n``` \n\t\t.text\n\t\t.file\t\"nono.c\"\n\t\t.globl\tmain\n\t\t.align\t16, 0x90\n\t\t.type\tmain,@function\n\tmain:                                   # @main\n\t\t.cfi_startproc\n\t# BB#0:\n\t\tpushq\t%rbp\n\t.Ltmp0:\n\t\t.cfi_def_cfa_offset 16\n\t.Ltmp1:\n\t\t.cfi_offset %rbp, -16\n\t\tmovq\t%rsp, %rbp\n\t.Ltmp2:\n\t\t.cfi_def_cfa_register %rbp\n\t\tsubq\t$32, %rsp\n\t\tleaq\t-15(%rbp), %rdi\n\t\tmovl\t$0, -4(%rbp)\n\t\tmovl\t.Lmain.side_a, %eax\n\t\tmovl\t%eax, -11(%rbp)\n\t\tmovw\t.Lmain.side_a+4, %cx\n\t\tmovw\t%cx, -7(%rbp)\n\t\tmovb\t.Lmain.side_a+6, %dl\n\t\tmovb\t%dl, -5(%rbp)\n\t\tmovl\t.Lmain.dont, %eax\n\t\tmovl\t%eax, -15(%rbp)\n\t\tmovl\t.Lmain.sidw_b, %eax\n\t\tmovl\t%eax, -22(%rbp)\n\t\tmovw\t.Lmain.sidw_b+4, %cx\n\t\tmovw\t%cx, -18(%rbp)\n\t\tmovb\t.Lmain.sidw_b+6, %dl\n\t\tmovb\t%dl, -16(%rbp)\n\t\tcallq\tputs\n\t\txorl\t%esi, %esi\n\t\tmovl\t%eax, -28(%rbp)         # 4-byte Spill\n\t\tmovl\t%esi, %eax\n\t\taddq\t$32, %rsp\n\t\tpopq\t%rbp\n\t\tretq\n    .Lfunc_end0:\n\t\t.size\tmain, .Lfunc_end0-main\n\t\t.cfi_endproc\n\n        .type   .Lmian.side_a,@object   # @main.side_a\n\t\t.section\t    .rodata.str1.1,\"aMS\",@progbits,1\n\n\t.Lmain.side_a:\n\t\t.asciz\t\"Side A\"\n\t\t.size\t.Lmain.side_a, 7\n\n\t\t.type\t.Lmain.dont,@object     # @main.dont\n\t\t.section\t.rodata.cst4,\"aM\",@progbits,4\n\t.Lmain.dont:\n\t\t.ascii\t\"WOW!\"\n\t\t.size\t.Lmain.dont, 4\n\n\t\t.type\t.Lmain.sidw_b,@object   # @main.sidw_b\n\t\t.section\t.rodata.str1.1,\"aMS\",@progbits,1\n\t.Lmain.sidw_b:\n\t\t.asciz\t\"Sdie B\"\n\t\t.size\t.Lmain.sidw_b, 7\n\n\n\t\t.ident\t\"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)\"\n\t\t.section\t\".note.GNU-stack\",\"\",@progbits\n```\n同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：\n\n```\n\t.Lmain.dont:\n\t\t.ascii\t\"WOW!\"\n\t\t.size\t.Lmain.dont, 4\n```\n\nsize 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。\n在 c 代碼總也可用 `sizeof` 來檢測是否有空字符:\n\n```c\n\tprintf(\"side_a: sizeof = %zd, strlen = %zd \\n\", sizeof （side_a), strlen(side_a));\n\tprintf(\"dont: sizeof = %zd, strlen = %zd \\n\", sizeof (dont), strlen(dont));\n\t// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符\n```\n\n反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。\n","slug":"null-character/index","published":1,"updated":"2017-05-29T11:22:50.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu4o0003mqlwuc65kn4r","content":"<h2 id=\"提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\"><a href=\"#提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\" class=\"headerlink\" title=\"提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\"></a>提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。</h2><a id=\"more\"></a>\n<p>然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 <code>\\0</code> 的 bug 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* File: reverse.c</span></div><div class=\"line\"> * Author: ByXc</div><div class=\"line\"> * About: reverse</div><div class=\"line\"> * Version: 1.0</div><div class=\"line\"> * Compilation: gcc 5.3.0 for MinGw</div><div class=\"line\"> * Date: 20170513</div><div class=\"line\"> * Github: ByXc01</div><div class=\"line\"> * Blog: http://ByXc01.github.io</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i_count;</div><div class=\"line\">\t<span class=\"keyword\">char</span> ch_string[<span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Please enter a string:\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, ch_string);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> (i_count = <span class=\"built_in\">strlen</span>(ch_string); i_count &gt;= <span class=\"number\">0</span>; i_count--)</div><div class=\"line\">\t    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch_string[i_count - <span class=\"number\">1</span>]);        <span class=\"comment\">//i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)</span></div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe all! \"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，</span></div><div class=\"line\">    * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。</div><div class=\"line\">    * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1</div><div class=\"line\">    */</div></pre></td></tr></table></figure>\n<p>這個程序很簡單， 是 《<em>c primer plus</em>》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 <code>i_count - 1</code>， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 <strong>“空格”</strong>， 輸出如下：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p><strong>後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ <code>if (*(ch_string + 4) == &#39; &#39;)</code> 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):</strong></p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string2.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>因為折騰的蠻久的， 印象也特別深刻。</p>\n<h2 id=\"接著在第十一章又見空字符\"><a href=\"#接著在第十一章又見空字符\" class=\"headerlink\" title=\"接著在第十一章又見空字符\"></a>接著在第十一章又見空字符</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> cha_string1[] = &#123; <span class=\"string\">'B'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'X'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'\\0'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string2[] = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string3 = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string4 = <span class=\"string\">\"ByXc\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string3[<span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\">cha_string[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">1</span>] = <span class=\"string\">'y'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">2</span>] = <span class=\"string\">'X'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">3</span>] = <span class=\"string\">'c'</span>;</div></pre></td></tr></table></figure>\n<p>以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。</p>\n<p><strong>所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)</strong></p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_strin3.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>讓我感覺想不通的還是程序清單 11.13 的輸出:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* nono.c -- 千萬不要模仿 */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> side_a[] = <span class=\"string\">\"Side A\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span> dont[] = &#123; <span class=\"string\">'W'</span>, <span class=\"string\">'O'</span>, <span class=\"string\">'W'</span>, <span class=\"string\">'!'</span> &#125;;</div><div class=\"line\">\t<span class=\"keyword\">char</span> side_b[] = <span class=\"string\">\"Side B\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">puts</span>(dont);\t\t<span class=\"comment\">// dont 不是一個字符串， 應是一個字符數組</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!Side A</div></pre></td></tr></table></figure>\n<p><strong>我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。</strong></p>\n<hr>\n<p>然而我的輸出為：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!</div></pre></td></tr></table></figure>\n<p>然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 <code>gcc -S</code> 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/character_array.png\" alt=\"沒有自動添加空字符啊\" title=\"沒有自動添加空字符啊\"></p>\n<p>可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string4.png\" alt=\"clang\" title=\"clang\"></p>\n<p>用 <code>clang -S</code> 編譯出來的彙編如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t.text</div><div class=\"line\">\t.file\t&quot;nono.c&quot;</div><div class=\"line\">\t.globl\tmain</div><div class=\"line\">\t.align\t16, 0x90</div><div class=\"line\">\t.type\tmain,@function</div><div class=\"line\">main:                                   # @main</div><div class=\"line\">\t.cfi_startproc</div><div class=\"line\"># BB#0:</div><div class=\"line\">\tpushq\t%rbp</div><div class=\"line\">.Ltmp0:</div><div class=\"line\">\t.cfi_def_cfa_offset 16</div><div class=\"line\">.Ltmp1:</div><div class=\"line\">\t.cfi_offset %rbp, -16</div><div class=\"line\">\tmovq\t%rsp, %rbp</div><div class=\"line\">.Ltmp2:</div><div class=\"line\">\t.cfi_def_cfa_register %rbp</div><div class=\"line\">\tsubq\t$32, %rsp</div><div class=\"line\">\tleaq\t-15(%rbp), %rdi</div><div class=\"line\">\tmovl\t$0, -4(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.side_a, %eax</div><div class=\"line\">\tmovl\t%eax, -11(%rbp)</div><div class=\"line\">\tmovw\t.Lmain.side_a+4, %cx</div><div class=\"line\">\tmovw\t%cx, -7(%rbp)</div><div class=\"line\">\tmovb\t.Lmain.side_a+6, %dl</div><div class=\"line\">\tmovb\t%dl, -5(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.dont, %eax</div><div class=\"line\">\tmovl\t%eax, -15(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.sidw_b, %eax</div><div class=\"line\">\tmovl\t%eax, -22(%rbp)</div><div class=\"line\">\tmovw\t.Lmain.sidw_b+4, %cx</div><div class=\"line\">\tmovw\t%cx, -18(%rbp)</div><div class=\"line\">\tmovb\t.Lmain.sidw_b+6, %dl</div><div class=\"line\">\tmovb\t%dl, -16(%rbp)</div><div class=\"line\">\tcallq\tputs</div><div class=\"line\">\txorl\t%esi, %esi</div><div class=\"line\">\tmovl\t%eax, -28(%rbp)         # 4-byte Spill</div><div class=\"line\">\tmovl\t%esi, %eax</div><div class=\"line\">\taddq\t$32, %rsp</div><div class=\"line\">\tpopq\t%rbp</div><div class=\"line\">\tretq</div><div class=\"line\">   .Lfunc_end0:</div><div class=\"line\">\t.size\tmain, .Lfunc_end0-main</div><div class=\"line\">\t.cfi_endproc</div><div class=\"line\"></div><div class=\"line\">       .type   .Lmian.side_a,@object   # @main.side_a</div><div class=\"line\">\t.section\t    .rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\"></div><div class=\"line\">.Lmain.side_a:</div><div class=\"line\">\t.asciz\t&quot;Side A&quot;</div><div class=\"line\">\t.size\t.Lmain.side_a, 7</div><div class=\"line\"></div><div class=\"line\">\t.type\t.Lmain.dont,@object     # @main.dont</div><div class=\"line\">\t.section\t.rodata.cst4,&quot;aM&quot;,@progbits,4</div><div class=\"line\">.Lmain.dont:</div><div class=\"line\">\t.ascii\t&quot;WOW!&quot;</div><div class=\"line\">\t.size\t.Lmain.dont, 4</div><div class=\"line\"></div><div class=\"line\">\t.type\t.Lmain.sidw_b,@object   # @main.sidw_b</div><div class=\"line\">\t.section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\">.Lmain.sidw_b:</div><div class=\"line\">\t.asciz\t&quot;Sdie B&quot;</div><div class=\"line\">\t.size\t.Lmain.sidw_b, 7</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t.ident\t&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</div><div class=\"line\">\t.section\t&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>\n<p>同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.Lmain.dont:</div><div class=\"line\">\t.ascii\t&quot;WOW!&quot;</div><div class=\"line\">\t.size\t.Lmain.dont, 4</div></pre></td></tr></table></figure>\n<p>size 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。<br>在 c 代碼總也可用 <code>sizeof</code> 來檢測是否有空字符:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"side_a: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> （side_a), <span class=\"built_in\">strlen</span>(side_a));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"dont: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> (dont), <span class=\"built_in\">strlen</span>(dont));</div><div class=\"line\"><span class=\"comment\">// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符</span></div></pre></td></tr></table></figure>\n<p>反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\"><a href=\"#提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\" class=\"headerlink\" title=\"提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\"></a>提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。</h2>","more":"<p>然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 <code>\\0</code> 的 bug 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* File: reverse.c</span></div><div class=\"line\"> * Author: ByXc</div><div class=\"line\"> * About: reverse</div><div class=\"line\"> * Version: 1.0</div><div class=\"line\"> * Compilation: gcc 5.3.0 for MinGw</div><div class=\"line\"> * Date: 20170513</div><div class=\"line\"> * Github: ByXc01</div><div class=\"line\"> * Blog: http://ByXc01.github.io</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i_count;</div><div class=\"line\">\t<span class=\"keyword\">char</span> ch_string[<span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Please enter a string:\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, ch_string);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> (i_count = <span class=\"built_in\">strlen</span>(ch_string); i_count &gt;= <span class=\"number\">0</span>; i_count--)</div><div class=\"line\">\t    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch_string[i_count - <span class=\"number\">1</span>]);        <span class=\"comment\">//i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)</span></div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe all! \"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，</span></div><div class=\"line\">    * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。</div><div class=\"line\">    * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1</div><div class=\"line\">    */</div></pre></td></tr></table></figure>\n<p>這個程序很簡單， 是 《<em>c primer plus</em>》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 <code>i_count - 1</code>， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 <strong>“空格”</strong>， 輸出如下：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p><strong>後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ <code>if (*(ch_string + 4) == &#39; &#39;)</code> 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):</strong></p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string2.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>因為折騰的蠻久的， 印象也特別深刻。</p>\n<h2 id=\"接著在第十一章又見空字符\"><a href=\"#接著在第十一章又見空字符\" class=\"headerlink\" title=\"接著在第十一章又見空字符\"></a>接著在第十一章又見空字符</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> cha_string1[] = &#123; <span class=\"string\">'B'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'X'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'\\0'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string2[] = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string3 = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string4 = <span class=\"string\">\"ByXc\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string3[<span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\">cha_string[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">1</span>] = <span class=\"string\">'y'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">2</span>] = <span class=\"string\">'X'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">3</span>] = <span class=\"string\">'c'</span>;</div></pre></td></tr></table></figure>\n<p>以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。</p>\n<p><strong>所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)</strong></p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_strin3.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>讓我感覺想不通的還是程序清單 11.13 的輸出:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* nono.c -- 千萬不要模仿 */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> side_a[] = <span class=\"string\">\"Side A\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span> dont[] = &#123; <span class=\"string\">'W'</span>, <span class=\"string\">'O'</span>, <span class=\"string\">'W'</span>, <span class=\"string\">'!'</span> &#125;;</div><div class=\"line\">\t<span class=\"keyword\">char</span> side_b[] = <span class=\"string\">\"Side B\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">puts</span>(dont);\t\t<span class=\"comment\">// dont 不是一個字符串， 應是一個字符數組</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!Side A</div></pre></td></tr></table></figure>\n<p><strong>我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。</strong></p>\n<hr>\n<p>然而我的輸出為：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!</div></pre></td></tr></table></figure>\n<p>然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 <code>gcc -S</code> 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/character_array.png\" alt=\"沒有自動添加空字符啊\" title=\"沒有自動添加空字符啊\"></p>\n<p>可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/null_string4.png\" alt=\"clang\" title=\"clang\"></p>\n<p>用 <code>clang -S</code> 編譯出來的彙編如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t.text</div><div class=\"line\">\t.file\t&quot;nono.c&quot;</div><div class=\"line\">\t.globl\tmain</div><div class=\"line\">\t.align\t16, 0x90</div><div class=\"line\">\t.type\tmain,@function</div><div class=\"line\">main:                                   # @main</div><div class=\"line\">\t.cfi_startproc</div><div class=\"line\"># BB#0:</div><div class=\"line\">\tpushq\t%rbp</div><div class=\"line\">.Ltmp0:</div><div class=\"line\">\t.cfi_def_cfa_offset 16</div><div class=\"line\">.Ltmp1:</div><div class=\"line\">\t.cfi_offset %rbp, -16</div><div class=\"line\">\tmovq\t%rsp, %rbp</div><div class=\"line\">.Ltmp2:</div><div class=\"line\">\t.cfi_def_cfa_register %rbp</div><div class=\"line\">\tsubq\t$32, %rsp</div><div class=\"line\">\tleaq\t-15(%rbp), %rdi</div><div class=\"line\">\tmovl\t$0, -4(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.side_a, %eax</div><div class=\"line\">\tmovl\t%eax, -11(%rbp)</div><div class=\"line\">\tmovw\t.Lmain.side_a+4, %cx</div><div class=\"line\">\tmovw\t%cx, -7(%rbp)</div><div class=\"line\">\tmovb\t.Lmain.side_a+6, %dl</div><div class=\"line\">\tmovb\t%dl, -5(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.dont, %eax</div><div class=\"line\">\tmovl\t%eax, -15(%rbp)</div><div class=\"line\">\tmovl\t.Lmain.sidw_b, %eax</div><div class=\"line\">\tmovl\t%eax, -22(%rbp)</div><div class=\"line\">\tmovw\t.Lmain.sidw_b+4, %cx</div><div class=\"line\">\tmovw\t%cx, -18(%rbp)</div><div class=\"line\">\tmovb\t.Lmain.sidw_b+6, %dl</div><div class=\"line\">\tmovb\t%dl, -16(%rbp)</div><div class=\"line\">\tcallq\tputs</div><div class=\"line\">\txorl\t%esi, %esi</div><div class=\"line\">\tmovl\t%eax, -28(%rbp)         # 4-byte Spill</div><div class=\"line\">\tmovl\t%esi, %eax</div><div class=\"line\">\taddq\t$32, %rsp</div><div class=\"line\">\tpopq\t%rbp</div><div class=\"line\">\tretq</div><div class=\"line\">   .Lfunc_end0:</div><div class=\"line\">\t.size\tmain, .Lfunc_end0-main</div><div class=\"line\">\t.cfi_endproc</div><div class=\"line\"></div><div class=\"line\">       .type   .Lmian.side_a,@object   # @main.side_a</div><div class=\"line\">\t.section\t    .rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\"></div><div class=\"line\">.Lmain.side_a:</div><div class=\"line\">\t.asciz\t&quot;Side A&quot;</div><div class=\"line\">\t.size\t.Lmain.side_a, 7</div><div class=\"line\"></div><div class=\"line\">\t.type\t.Lmain.dont,@object     # @main.dont</div><div class=\"line\">\t.section\t.rodata.cst4,&quot;aM&quot;,@progbits,4</div><div class=\"line\">.Lmain.dont:</div><div class=\"line\">\t.ascii\t&quot;WOW!&quot;</div><div class=\"line\">\t.size\t.Lmain.dont, 4</div><div class=\"line\"></div><div class=\"line\">\t.type\t.Lmain.sidw_b,@object   # @main.sidw_b</div><div class=\"line\">\t.section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\">.Lmain.sidw_b:</div><div class=\"line\">\t.asciz\t&quot;Sdie B&quot;</div><div class=\"line\">\t.size\t.Lmain.sidw_b, 7</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t.ident\t&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</div><div class=\"line\">\t.section\t&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>\n<p>同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.Lmain.dont:</div><div class=\"line\">\t.ascii\t&quot;WOW!&quot;</div><div class=\"line\">\t.size\t.Lmain.dont, 4</div></pre></td></tr></table></figure>\n<p>size 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。<br>在 c 代碼總也可用 <code>sizeof</code> 來檢測是否有空字符:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"side_a: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> （side_a), <span class=\"built_in\">strlen</span>(side_a));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"dont: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> (dont), <span class=\"built_in\">strlen</span>(dont));</div><div class=\"line\"><span class=\"comment\">// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符</span></div></pre></td></tr></table></figure>\n<p>反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。</p>"},{"title":"programme_exercise","date":"2017-05-26T13:22:05.000Z","_content":"\n# c primer plus 6 programme exercise\n\n本人在 c primer plus 中文第六版的[編程練習題](https://github.com/ByXc01/cpp6-programme-exercise \"編程練習題\")做的答案(不定期更新)。\n如有有需要的的朋友可自行clone。 部分源碼參考標準答案。\n(可能本人做的不太好，望見諒。出錯請指針。有更好題的可以fork合並)\n這已經算我在github 的一個大項目了，dalao 自行忽略。\n\n<!--more-->\n\n![編程練習](http://opkl2tvjd.bkt.clouddn.com/2017-05-27%2000-40-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png \"編程練習\")\n","source":"_posts/programme-exercise/index.md","raw":"---\ntitle: programme_exercise\ndate: 2017-05-26 21:22:05\ntags: github\n---\n\n# c primer plus 6 programme exercise\n\n本人在 c primer plus 中文第六版的[編程練習題](https://github.com/ByXc01/cpp6-programme-exercise \"編程練習題\")做的答案(不定期更新)。\n如有有需要的的朋友可自行clone。 部分源碼參考標準答案。\n(可能本人做的不太好，望見諒。出錯請指針。有更好題的可以fork合並)\n這已經算我在github 的一個大項目了，dalao 自行忽略。\n\n<!--more-->\n\n![編程練習](http://opkl2tvjd.bkt.clouddn.com/2017-05-27%2000-40-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png \"編程練習\")\n","slug":"programme-exercise/index","published":1,"updated":"2017-05-26T17:17:06.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu4v0004mqlw1mtwitxv","content":"<h1 id=\"c-primer-plus-6-programme-exercise\"><a href=\"#c-primer-plus-6-programme-exercise\" class=\"headerlink\" title=\"c primer plus 6 programme exercise\"></a>c primer plus 6 programme exercise</h1><p>本人在 c primer plus 中文第六版的<a href=\"https://github.com/ByXc01/cpp6-programme-exercise\" title=\"編程練習題\" target=\"_blank\" rel=\"external\">編程練習題</a>做的答案(不定期更新)。<br>如有有需要的的朋友可自行clone。 部分源碼參考標準答案。<br>(可能本人做的不太好，望見諒。出錯請指針。有更好題的可以fork合並)<br>這已經算我在github 的一個大項目了，dalao 自行忽略。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/2017-05-27%2000-40-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\" alt=\"編程練習\" title=\"編程練習\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"c-primer-plus-6-programme-exercise\"><a href=\"#c-primer-plus-6-programme-exercise\" class=\"headerlink\" title=\"c primer plus 6 programme exercise\"></a>c primer plus 6 programme exercise</h1><p>本人在 c primer plus 中文第六版的<a href=\"https://github.com/ByXc01/cpp6-programme-exercise\" title=\"編程練習題\" target=\"_blank\" rel=\"external\">編程練習題</a>做的答案(不定期更新)。<br>如有有需要的的朋友可自行clone。 部分源碼參考標準答案。<br>(可能本人做的不太好，望見諒。出錯請指針。有更好題的可以fork合並)<br>這已經算我在github 的一個大項目了，dalao 自行忽略。</p>","more":"<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/2017-05-27%2000-40-01%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png\" alt=\"編程練習\" title=\"編程練習\"></p>"},{"title":"關於尾遞歸的問題","date":"2017-05-26T12:43:33.000Z","_content":"\n### （我們今天來談談尾遞歸的問題）\n\n***\n\n### c primer plus 定義\n\n**尾遞歸**， 這是本人學到遞歸的一個疑惑點。 在 《*c primer plus* 》中文第六版中，\n\n尾遞歸的是這樣定義的：\n\n**“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在`return`語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”**\n\n<!--more-->\n\n---\n\n接著書上給的尾遞歸例子是這樣的:\n\n\n``` c\n    long rfact(int n)\n    {\n        long ans;\n\n        if (n > 0)\n            ans = n * rfact(n - 1);\n        else\n            ans = 1;\n\n        return ans;\n    }\n\n```\n\n這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《*c primer plus*》的定義，也是算尾遞歸吧)：\n\n``` c\n\tlong rfact(int n)\n\t{\n\t\tif (n <= 1)\n            return 1;\n\n\t\treturn rfact(n - 1) * n;\t\t// 省略不必要的存儲\n\t}\n```\n* * *\n\n別以為就這樣就完事了， 那時候我對**尾遞歸**還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。\n\n但是在百度百科是這樣定義的：\n\n### 百度百科定義\n\n**“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”**\n\n(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：\n\n``` c\n\tint facttail(int n, int a)\n\n\t{\n\t\t/* Compute a factorialina tail - recursive manner */\n\n\t\tif (n < 0)\n            return 0;\n\t\telse if (n == 0)\n            return 1;\n\t\telse if (n == 1)\n            return a;\n\t\telse\n            return facttail(n - 1, n * a);\n\t}\n```\n\n**“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”**\n\n沒錯，照百度百科的定義這個代碼才是**尾遞歸**， 算法也比前兩個例子簡便要好許多。\n\n- - -\n\n### 博客園 twoon 的博客截取\n\n在博客園看到一個不錯的博文[說說尾遞歸](http://www.cnblogs.com/catch/p/3495450.html \"說說尾遞歸\")\n\n博文中的**尾遞歸**的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。\n\n### 什麼是尾遞歸\n\n什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。\n\n``` c\n\t// 先不考慮溢出的問題\n\tint func(int n)\n\t{\n\t\tif (n <= 1)\n            return 1;\n\n\t\treturn (n * func(n - 1));\n\t}\n```\n\n原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:\n\n*  1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。\n\n*  2: 執行函數。\n\n*  3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 **gdb** 和一點 **彙編** 再作深入研究)\n\n因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C ... 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。\n\n**而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:**\n\n``` c\n\t// 先不考慮溢出\n\tint tail_func(int n, int res)\n\t{\n\t\tif (n <= 1)\n            return res;\n\n\t\treturn tail_func(n - 1, n * res);\n\t}\n```\n\n``` c\n\t// 向下面這樣調用\n\ttail_func(10000000000, 1);\n```\n\n從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n \\* res) 的返回值，才能計算它自己的返回結果 -- 它就完全等於 tail_fun(n - 1, n \\* res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。\n\n這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！\n\n### 尾遞歸的調用棧優化特性\n\n相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：\n\n``` c\n\t#include <stdio.h>\n\n\tint tail_func(int n, int res)\n\t{\n\t\tif (n <= 1)\n            return res;\n\n\t\treturn tail_func(n - 1, n * res);\n\t}\n\n\tint main(void)\n\t{\n\t\tint dummy[1014 * 1024];\t\t// 盡可能佔用棧\n\n\t\ttail_func(2048 * 2048, 1);\n\n\t\treturn 0;\n\t}\n```\n\n上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 `gcc -Wall factorial_tail.c `編譯讓後運行的話，程序會包棧崩潰。\n\n沒開編譯優化：\n\n![沒開編譯優化](http://opkl2tvjd.bkt.clouddn.com/not_o2.png \"沒開編譯優化\")\n\n但如果開優化的話： `gcc -Wall -O2 factorial_tail.c`， 上面的程序最後就能正常運行。\n\n開了`-O2` 編譯優化:\n\n![開了 -O2 編譯優化](http://opkl2tvjd.bkt.clouddn.com/02.png \"開了 -O2 編譯優化\")\n\n**這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。**\n\n我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 \n\n![沒開優化彙編](http://opkl2tvjd.bkt.clouddn.com/not_no2s.png \"沒開優化彙編\")\n\n**注意上面 `tail_func` 函數中的 `call` 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 `jmp` 去 `tail_func`， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。**\n\n我們在看看開了優化得到的彙編:\n\n![開了優化彙編](http://opkl2tvjd.bkt.clouddn.com/o2eds.png \"開了優化彙編\")\n\n注意 `tail_func` 函數彙編中 `imull %ecx, %eax` 和 `jne .L3`。`tail_func()` 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!\n\n這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。\n\n## 結束語\n\n好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。\n\n還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。\n\n**最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)**\n\n#  Happy Birthday to myself.\n","source":"_posts/tail-recursion/index.md","raw":"---\ntitle: 關於尾遞歸的問題\ndate: 2017-05-26 20:43:33\ntags: 尾遞歸\n---\n\n### （我們今天來談談尾遞歸的問題）\n\n***\n\n### c primer plus 定義\n\n**尾遞歸**， 這是本人學到遞歸的一個疑惑點。 在 《*c primer plus* 》中文第六版中，\n\n尾遞歸的是這樣定義的：\n\n**“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在`return`語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”**\n\n<!--more-->\n\n---\n\n接著書上給的尾遞歸例子是這樣的:\n\n\n``` c\n    long rfact(int n)\n    {\n        long ans;\n\n        if (n > 0)\n            ans = n * rfact(n - 1);\n        else\n            ans = 1;\n\n        return ans;\n    }\n\n```\n\n這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《*c primer plus*》的定義，也是算尾遞歸吧)：\n\n``` c\n\tlong rfact(int n)\n\t{\n\t\tif (n <= 1)\n            return 1;\n\n\t\treturn rfact(n - 1) * n;\t\t// 省略不必要的存儲\n\t}\n```\n* * *\n\n別以為就這樣就完事了， 那時候我對**尾遞歸**還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。\n\n但是在百度百科是這樣定義的：\n\n### 百度百科定義\n\n**“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”**\n\n(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：\n\n``` c\n\tint facttail(int n, int a)\n\n\t{\n\t\t/* Compute a factorialina tail - recursive manner */\n\n\t\tif (n < 0)\n            return 0;\n\t\telse if (n == 0)\n            return 1;\n\t\telse if (n == 1)\n            return a;\n\t\telse\n            return facttail(n - 1, n * a);\n\t}\n```\n\n**“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”**\n\n沒錯，照百度百科的定義這個代碼才是**尾遞歸**， 算法也比前兩個例子簡便要好許多。\n\n- - -\n\n### 博客園 twoon 的博客截取\n\n在博客園看到一個不錯的博文[說說尾遞歸](http://www.cnblogs.com/catch/p/3495450.html \"說說尾遞歸\")\n\n博文中的**尾遞歸**的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。\n\n### 什麼是尾遞歸\n\n什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。\n\n``` c\n\t// 先不考慮溢出的問題\n\tint func(int n)\n\t{\n\t\tif (n <= 1)\n            return 1;\n\n\t\treturn (n * func(n - 1));\n\t}\n```\n\n原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:\n\n*  1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。\n\n*  2: 執行函數。\n\n*  3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 **gdb** 和一點 **彙編** 再作深入研究)\n\n因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C ... 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。\n\n**而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:**\n\n``` c\n\t// 先不考慮溢出\n\tint tail_func(int n, int res)\n\t{\n\t\tif (n <= 1)\n            return res;\n\n\t\treturn tail_func(n - 1, n * res);\n\t}\n```\n\n``` c\n\t// 向下面這樣調用\n\ttail_func(10000000000, 1);\n```\n\n從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n \\* res) 的返回值，才能計算它自己的返回結果 -- 它就完全等於 tail_fun(n - 1, n \\* res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。\n\n這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！\n\n### 尾遞歸的調用棧優化特性\n\n相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：\n\n``` c\n\t#include <stdio.h>\n\n\tint tail_func(int n, int res)\n\t{\n\t\tif (n <= 1)\n            return res;\n\n\t\treturn tail_func(n - 1, n * res);\n\t}\n\n\tint main(void)\n\t{\n\t\tint dummy[1014 * 1024];\t\t// 盡可能佔用棧\n\n\t\ttail_func(2048 * 2048, 1);\n\n\t\treturn 0;\n\t}\n```\n\n上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 `gcc -Wall factorial_tail.c `編譯讓後運行的話，程序會包棧崩潰。\n\n沒開編譯優化：\n\n![沒開編譯優化](http://opkl2tvjd.bkt.clouddn.com/not_o2.png \"沒開編譯優化\")\n\n但如果開優化的話： `gcc -Wall -O2 factorial_tail.c`， 上面的程序最後就能正常運行。\n\n開了`-O2` 編譯優化:\n\n![開了 -O2 編譯優化](http://opkl2tvjd.bkt.clouddn.com/02.png \"開了 -O2 編譯優化\")\n\n**這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。**\n\n我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 \n\n![沒開優化彙編](http://opkl2tvjd.bkt.clouddn.com/not_no2s.png \"沒開優化彙編\")\n\n**注意上面 `tail_func` 函數中的 `call` 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 `jmp` 去 `tail_func`， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。**\n\n我們在看看開了優化得到的彙編:\n\n![開了優化彙編](http://opkl2tvjd.bkt.clouddn.com/o2eds.png \"開了優化彙編\")\n\n注意 `tail_func` 函數彙編中 `imull %ecx, %eax` 和 `jne .L3`。`tail_func()` 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!\n\n這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。\n\n## 結束語\n\n好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。\n\n還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。\n\n**最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)**\n\n#  Happy Birthday to myself.\n","slug":"tail-recursion/index","published":1,"updated":"2017-05-29T11:34:14.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu5a0006mqlwdggd8jy4","content":"<h3 id=\"（我們今天來談談尾遞歸的問題）\"><a href=\"#（我們今天來談談尾遞歸的問題）\" class=\"headerlink\" title=\"（我們今天來談談尾遞歸的問題）\"></a>（我們今天來談談尾遞歸的問題）</h3><hr>\n<h3 id=\"c-primer-plus-定義\"><a href=\"#c-primer-plus-定義\" class=\"headerlink\" title=\"c primer plus 定義\"></a>c primer plus 定義</h3><p><strong>尾遞歸</strong>， 這是本人學到遞歸的一個疑惑點。 在 《<em>c primer plus</em> 》中文第六版中，</p>\n<p>尾遞歸的是這樣定義的：</p>\n<p><strong>“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在<code>return</code>語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”</strong></p>\n<a id=\"more\"></a>\n<hr>\n<p>接著書上給的尾遞歸例子是這樣的:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> ans;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        ans = n * rfact(n - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        ans = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《<em>c primer plus</em>》的定義，也是算尾遞歸吧)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> rfact(n - <span class=\"number\">1</span>) * n;\t\t<span class=\"comment\">// 省略不必要的存儲</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>別以為就這樣就完事了， 那時候我對<strong>尾遞歸</strong>還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。</p>\n<p>但是在百度百科是這樣定義的：</p>\n<h3 id=\"百度百科定義\"><a href=\"#百度百科定義\" class=\"headerlink\" title=\"百度百科定義\"></a>百度百科定義</h3><p><strong>“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”</strong></p>\n<p>(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">facttail</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> a)</span></span></div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">/* Compute a factorialina tail - recursive manner */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> a;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">           <span class=\"keyword\">return</span> facttail(n - <span class=\"number\">1</span>, n * a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”</strong></p>\n<p>沒錯，照百度百科的定義這個代碼才是<strong>尾遞歸</strong>， 算法也比前兩個例子簡便要好許多。</p>\n<hr>\n<h3 id=\"博客園-twoon-的博客截取\"><a href=\"#博客園-twoon-的博客截取\" class=\"headerlink\" title=\"博客園 twoon 的博客截取\"></a>博客園 twoon 的博客截取</h3><p>在博客園看到一個不錯的博文<a href=\"http://www.cnblogs.com/catch/p/3495450.html\" title=\"說說尾遞歸\" target=\"_blank\" rel=\"external\">說說尾遞歸</a></p>\n<p>博文中的<strong>尾遞歸</strong>的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。</p>\n<h3 id=\"什麼是尾遞歸\"><a href=\"#什麼是尾遞歸\" class=\"headerlink\" title=\"什麼是尾遞歸\"></a>什麼是尾遞歸</h3><p>什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出的問題</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> (n * func(n - <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:</p>\n<ul>\n<li><p>1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。</p>\n</li>\n<li><p>2: 執行函數。</p>\n</li>\n<li><p>3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 <strong>gdb</strong> 和一點 <strong>彙編</strong> 再作深入研究)</p>\n</li>\n</ul>\n<p>因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C … 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。</p>\n<p><strong>而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 向下面這樣調用</span></div><div class=\"line\">tail_func(<span class=\"number\">10000000000</span>, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<p>從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n * res) 的返回值，才能計算它自己的返回結果 – 它就完全等於 tail_fun(n - 1, n * res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。</p>\n<p>這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！</p>\n<h3 id=\"尾遞歸的調用棧優化特性\"><a href=\"#尾遞歸的調用棧優化特性\" class=\"headerlink\" title=\"尾遞歸的調用棧優化特性\"></a>尾遞歸的調用棧優化特性</h3><p>相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> dummy[<span class=\"number\">1014</span> * <span class=\"number\">1024</span>];\t\t<span class=\"comment\">// 盡可能佔用棧</span></div><div class=\"line\"></div><div class=\"line\">\ttail_func(<span class=\"number\">2048</span> * <span class=\"number\">2048</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 <code>gcc -Wall factorial_tail.c</code>編譯讓後運行的話，程序會包棧崩潰。</p>\n<p>沒開編譯優化：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/not_o2.png\" alt=\"沒開編譯優化\" title=\"沒開編譯優化\"></p>\n<p>但如果開優化的話： <code>gcc -Wall -O2 factorial_tail.c</code>， 上面的程序最後就能正常運行。</p>\n<p>開了<code>-O2</code> 編譯優化:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/02.png\" alt=\"開了 -O2 編譯優化\" title=\"開了 -O2 編譯優化\"></p>\n<p><strong>這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。</strong></p>\n<p>我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 </p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/not_no2s.png\" alt=\"沒開優化彙編\" title=\"沒開優化彙編\"></p>\n<p><strong>注意上面 <code>tail_func</code> 函數中的 <code>call</code> 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 <code>jmp</code> 去 <code>tail_func</code>， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。</strong></p>\n<p>我們在看看開了優化得到的彙編:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/o2eds.png\" alt=\"開了優化彙編\" title=\"開了優化彙編\"></p>\n<p>注意 <code>tail_func</code> 函數彙編中 <code>imull %ecx, %eax</code> 和 <code>jne .L3</code>。<code>tail_func()</code> 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!</p>\n<p>這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。</p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。</p>\n<p>還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。</p>\n<p><strong>最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)</strong></p>\n<h1 id=\"Happy-Birthday-to-myself\"><a href=\"#Happy-Birthday-to-myself\" class=\"headerlink\" title=\"Happy Birthday to myself.\"></a>Happy Birthday to myself.</h1>","site":{"data":{}},"excerpt":"<h3 id=\"（我們今天來談談尾遞歸的問題）\"><a href=\"#（我們今天來談談尾遞歸的問題）\" class=\"headerlink\" title=\"（我們今天來談談尾遞歸的問題）\"></a>（我們今天來談談尾遞歸的問題）</h3><hr>\n<h3 id=\"c-primer-plus-定義\"><a href=\"#c-primer-plus-定義\" class=\"headerlink\" title=\"c primer plus 定義\"></a>c primer plus 定義</h3><p><strong>尾遞歸</strong>， 這是本人學到遞歸的一個疑惑點。 在 《<em>c primer plus</em> 》中文第六版中，</p>\n<p>尾遞歸的是這樣定義的：</p>\n<p><strong>“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在<code>return</code>語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”</strong></p>","more":"<hr>\n<p>接著書上給的尾遞歸例子是這樣的:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> ans;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        ans = n * rfact(n - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        ans = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《<em>c primer plus</em>》的定義，也是算尾遞歸吧)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> rfact(n - <span class=\"number\">1</span>) * n;\t\t<span class=\"comment\">// 省略不必要的存儲</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>別以為就這樣就完事了， 那時候我對<strong>尾遞歸</strong>還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。</p>\n<p>但是在百度百科是這樣定義的：</p>\n<h3 id=\"百度百科定義\"><a href=\"#百度百科定義\" class=\"headerlink\" title=\"百度百科定義\"></a>百度百科定義</h3><p><strong>“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”</strong></p>\n<p>(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">facttail</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> a)</span></span></div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">/* Compute a factorialina tail - recursive manner */</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> a;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">           <span class=\"keyword\">return</span> facttail(n - <span class=\"number\">1</span>, n * a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”</strong></p>\n<p>沒錯，照百度百科的定義這個代碼才是<strong>尾遞歸</strong>， 算法也比前兩個例子簡便要好許多。</p>\n<hr>\n<h3 id=\"博客園-twoon-的博客截取\"><a href=\"#博客園-twoon-的博客截取\" class=\"headerlink\" title=\"博客園 twoon 的博客截取\"></a>博客園 twoon 的博客截取</h3><p>在博客園看到一個不錯的博文<a href=\"http://www.cnblogs.com/catch/p/3495450.html\" title=\"說說尾遞歸\" target=\"_blank\" rel=\"external\">說說尾遞歸</a></p>\n<p>博文中的<strong>尾遞歸</strong>的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。</p>\n<h3 id=\"什麼是尾遞歸\"><a href=\"#什麼是尾遞歸\" class=\"headerlink\" title=\"什麼是尾遞歸\"></a>什麼是尾遞歸</h3><p>什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出的問題</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> (n * func(n - <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:</p>\n<ul>\n<li><p>1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。</p>\n</li>\n<li><p>2: 執行函數。</p>\n</li>\n<li><p>3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 <strong>gdb</strong> 和一點 <strong>彙編</strong> 再作深入研究)</p>\n</li>\n</ul>\n<p>因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C … 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。</p>\n<p><strong>而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 向下面這樣調用</span></div><div class=\"line\">tail_func(<span class=\"number\">10000000000</span>, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<p>從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n * res) 的返回值，才能計算它自己的返回結果 – 它就完全等於 tail_fun(n - 1, n * res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。</p>\n<p>這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！</p>\n<h3 id=\"尾遞歸的調用棧優化特性\"><a href=\"#尾遞歸的調用棧優化特性\" class=\"headerlink\" title=\"尾遞歸的調用棧優化特性\"></a>尾遞歸的調用棧優化特性</h3><p>相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> dummy[<span class=\"number\">1014</span> * <span class=\"number\">1024</span>];\t\t<span class=\"comment\">// 盡可能佔用棧</span></div><div class=\"line\"></div><div class=\"line\">\ttail_func(<span class=\"number\">2048</span> * <span class=\"number\">2048</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 <code>gcc -Wall factorial_tail.c</code>編譯讓後運行的話，程序會包棧崩潰。</p>\n<p>沒開編譯優化：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/not_o2.png\" alt=\"沒開編譯優化\" title=\"沒開編譯優化\"></p>\n<p>但如果開優化的話： <code>gcc -Wall -O2 factorial_tail.c</code>， 上面的程序最後就能正常運行。</p>\n<p>開了<code>-O2</code> 編譯優化:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/02.png\" alt=\"開了 -O2 編譯優化\" title=\"開了 -O2 編譯優化\"></p>\n<p><strong>這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。</strong></p>\n<p>我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 </p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/not_no2s.png\" alt=\"沒開優化彙編\" title=\"沒開優化彙編\"></p>\n<p><strong>注意上面 <code>tail_func</code> 函數中的 <code>call</code> 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 <code>jmp</code> 去 <code>tail_func</code>， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。</strong></p>\n<p>我們在看看開了優化得到的彙編:</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/o2eds.png\" alt=\"開了優化彙編\" title=\"開了優化彙編\"></p>\n<p>注意 <code>tail_func</code> 函數彙編中 <code>imull %ecx, %eax</code> 和 <code>jne .L3</code>。<code>tail_func()</code> 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!</p>\n<p>這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。</p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。</p>\n<p>還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。</p>\n<p><strong>最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)</strong></p>\n<h1 id=\"Happy-Birthday-to-myself\"><a href=\"#Happy-Birthday-to-myself\" class=\"headerlink\" title=\"Happy Birthday to myself.\"></a>Happy Birthday to myself.</h1>"},{"title":"C11 gets_s() 函數","date":"2017-05-29T10:20:27.000Z","_content":"\n### C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\n\nC11 K.3.5.7.1 The gets_s function 代碼如下:\n\n```c\n\t#define __STDC_WANT_LIB_EXT1__ 1\n\t#include <stdio.h>\n\tchar * gets_s(char *s, rsize_t n);\n```\n<!--more-->\n\n### 因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\n\n在 《*c primer plus*》 也沒過多的介紹。\n\n![get_s() 介紹](http://opkl2tvjd.bkt.clouddn.com/gets_s.png \"gets_s()介紹\")\n\n詳細可查看[C 語言參考手冊](http://zh.cppreference.com/w/c/io/gets \"C 語言查考手冊\")\n","source":"_posts/gets-s/gets_s.md","raw":"---\ntitle: C11 gets_s() 函數\ndate: 2017-05-29 18:20:27\ntags: gets_s\n---\n\n### C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\n\nC11 K.3.5.7.1 The gets_s function 代碼如下:\n\n```c\n\t#define __STDC_WANT_LIB_EXT1__ 1\n\t#include <stdio.h>\n\tchar * gets_s(char *s, rsize_t n);\n```\n<!--more-->\n\n### 因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\n\n在 《*c primer plus*》 也沒過多的介紹。\n\n![get_s() 介紹](http://opkl2tvjd.bkt.clouddn.com/gets_s.png \"gets_s()介紹\")\n\n詳細可查看[C 語言參考手冊](http://zh.cppreference.com/w/c/io/gets \"C 語言查考手冊\")\n","slug":"gets-s/gets_s","published":1,"updated":"2017-05-29T11:25:35.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu5j0007mqlwqjc25oee","content":"<h3 id=\"C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\"><a href=\"#C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\" class=\"headerlink\" title=\"C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\"></a>C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。</h3><p>C11 K.3.5.7.1 The gets_s function 代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __STDC_WANT_LIB_EXT1__ 1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">gets_s</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">rsize_t</span> n)</span></span>;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\"><a href=\"#因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\" class=\"headerlink\" title=\"因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\"></a>因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。</h3><p>在 《<em>c primer plus</em>》 也沒過多的介紹。</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/gets_s.png\" alt=\"get_s() 介紹\" title=\"gets_s()介紹\"></p>\n<p>詳細可查看<a href=\"http://zh.cppreference.com/w/c/io/gets\" title=\"C 語言查考手冊\" target=\"_blank\" rel=\"external\">C 語言參考手冊</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\"><a href=\"#C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\" class=\"headerlink\" title=\"C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\"></a>C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。</h3><p>C11 K.3.5.7.1 The gets_s function 代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __STDC_WANT_LIB_EXT1__ 1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">gets_s</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">rsize_t</span> n)</span></span>;</div></pre></td></tr></table></figure>","more":"<h3 id=\"因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\"><a href=\"#因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\" class=\"headerlink\" title=\"因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\"></a>因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。</h3><p>在 《<em>c primer plus</em>》 也沒過多的介紹。</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/gets_s.png\" alt=\"get_s() 介紹\" title=\"gets_s()介紹\"></p>\n<p>詳細可查看<a href=\"http://zh.cppreference.com/w/c/io/gets\" title=\"C 語言查考手冊\" target=\"_blank\" rel=\"external\">C 語言參考手冊</a></p>"},{"title":"Hello World","date":"2017-05-06T05:14:52.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-05-06 13:14:52\ntags: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world/hello-world","published":1,"updated":"2017-05-29T10:57:31.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu5z0008mqlwhnb8m69y","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><a id=\"more\"></a>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>"},{"title":"ByXc's blog","date":"2017-05-06T08:55:29.000Z","_content":"## Hello , Welcome to ByXc's blog.\n\n<!--more-->\n\n* 這是用 hexo + github 搭建的個人博客，\n* 有空會發一些個人學習的一些文章博客。\n* 身爲初學者， 老鳥無噴啊。\n* 先來一段 c語言的 Hello World 再說。\n\n``` c\n    #inlcude <stdio.h>\n    int main(void)\n    {\n        printf(\"hello world \\n\");\n\n        return 0;\n    }\n```\n***\n\n* 初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。\n* 附上logo：\n\n ![](http://opkl2tvjd.bkt.clouddn.com/17-5-7/94556521-file_1494140192949_4bbe.jpg)\n","source":"_posts/hello-byxc/hello-byxc.md","raw":"---\ntitle: ByXc's blog             # 可以改成中文的， 如\"你好世界\"\ndate: 2017-05-06 16:55:29\ntags: hello\n---\n## Hello , Welcome to ByXc's blog.\n\n<!--more-->\n\n* 這是用 hexo + github 搭建的個人博客，\n* 有空會發一些個人學習的一些文章博客。\n* 身爲初學者， 老鳥無噴啊。\n* 先來一段 c語言的 Hello World 再說。\n\n``` c\n    #inlcude <stdio.h>\n    int main(void)\n    {\n        printf(\"hello world \\n\");\n\n        return 0;\n    }\n```\n***\n\n* 初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。\n* 附上logo：\n\n ![](http://opkl2tvjd.bkt.clouddn.com/17-5-7/94556521-file_1494140192949_4bbe.jpg)\n","slug":"hello-byxc/hello-byxc","published":1,"updated":"2017-05-26T16:44:47.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3a2cu7k000imqlwd14iplch","content":"<h2 id=\"Hello-Welcome-to-ByXc’s-blog\"><a href=\"#Hello-Welcome-to-ByXc’s-blog\" class=\"headerlink\" title=\"Hello , Welcome to ByXc’s blog.\"></a>Hello , Welcome to ByXc’s blog.</h2><a id=\"more\"></a>\n<ul>\n<li>這是用 hexo + github 搭建的個人博客，</li>\n<li>有空會發一些個人學習的一些文章博客。</li>\n<li>身爲初學者， 老鳥無噴啊。</li>\n<li>先來一段 c語言的 Hello World 再說。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#inlcude <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world \\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。</li>\n<li><p>附上logo：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/17-5-7/94556521-file_1494140192949_4bbe.jpg\" alt=\"\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Hello-Welcome-to-ByXc’s-blog\"><a href=\"#Hello-Welcome-to-ByXc’s-blog\" class=\"headerlink\" title=\"Hello , Welcome to ByXc’s blog.\"></a>Hello , Welcome to ByXc’s blog.</h2>","more":"<ul>\n<li>這是用 hexo + github 搭建的個人博客，</li>\n<li>有空會發一些個人學習的一些文章博客。</li>\n<li>身爲初學者， 老鳥無噴啊。</li>\n<li>先來一段 c語言的 Hello World 再說。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#inlcude <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world \\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。</li>\n<li><p>附上logo：</p>\n<p><img src=\"http://opkl2tvjd.bkt.clouddn.com/17-5-7/94556521-file_1494140192949_4bbe.jpg\" alt=\"\"></p>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj3a2cu280000mqlwg3hfbfz5","tag_id":"cj3a2cu3c0001mqlwg0tyhtey","_id":"cj3a2cu3v0002mqlwwy4bn6y4"},{"post_id":"cj3a2cu4o0003mqlwuc65kn4r","tag_id":"cj3a2cu580005mqlw3cayxx6w","_id":"cj3a2cu63000amqlwdnv6k5qx"},{"post_id":"cj3a2cu4v0004mqlw1mtwitxv","tag_id":"cj3a2cu630009mqlwbeg9n9nz","_id":"cj3a2cu67000cmqlwav2xbw2e"},{"post_id":"cj3a2cu5a0006mqlwdggd8jy4","tag_id":"cj3a2cu66000bmqlwyb28q2bz","_id":"cj3a2cu68000emqlwvcmke04v"},{"post_id":"cj3a2cu5j0007mqlwqjc25oee","tag_id":"cj3a2cu67000dmqlwlfxcvdcp","_id":"cj3a2cu69000gmqlwwcvl41h6"},{"post_id":"cj3a2cu5z0008mqlwhnb8m69y","tag_id":"cj3a2cu68000fmqlwiawoxhm9","_id":"cj3a2cu69000hmqlwdpu3g6nc"},{"post_id":"cj3a2cu7k000imqlwd14iplch","tag_id":"cj3a2cu7y000jmqlw47hj1dqs","_id":"cj3a2cu7z000kmqlwl76898vh"}],"Tag":[{"name":"随笔","_id":"cj3a2cu3c0001mqlwg0tyhtey"},{"name":"空字符","_id":"cj3a2cu580005mqlw3cayxx6w"},{"name":"github","_id":"cj3a2cu630009mqlwbeg9n9nz"},{"name":"尾遞歸","_id":"cj3a2cu66000bmqlwyb28q2bz"},{"name":"gets_s","_id":"cj3a2cu67000dmqlwlfxcvdcp"},{"name":"Hello World","_id":"cj3a2cu68000fmqlwiawoxhm9"},{"name":"hello","_id":"cj3a2cu7y000jmqlw47hj1dqs"}]}}