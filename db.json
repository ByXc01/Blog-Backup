{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/logo.jpg","path":"img/logo.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1494120223099},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1494120223099},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1494120223099},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1494120223099},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1494120223099},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1494120223099},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1494120223099},{"_id":"themes/yilia/_config.yml","hash":"690c4ac744dcb55f46a1374e522a7c6761a93d48","modified":1503584477517},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1494120223139},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1494120223107},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"8f4a22eb786c9e9bbdc102cb29a642ac853a224d","modified":1494121508241},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"891805485d22f9cbd7a1042d98f7953414f4c0fd","modified":1494121508418},{"_id":"themes/yilia/.git/config","hash":"45dbf7cad960774e3ebd63f878005463a78e4c69","modified":1494120218550},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1494120218522},{"_id":"themes/yilia/.git/index","hash":"dfc86c63a0717854f7b0125894bc14471ec16b5f","modified":1497098709212},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1494120223107},{"_id":"themes/yilia/.git/packed-refs","hash":"a8140137954dec646b34af234b44895c240f8f38","modified":1494120218502},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1494118823551},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1494120223127},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1494120223099},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1494120223099},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1494120223099},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1494120223099},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1494120223131},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1494120223099},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1494120223099},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1494120223099},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1494120223139},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1494120223103},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1494120223103},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1494120223103},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1494120223107},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1494120223103},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1494120223103},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1494120223103},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1494120223135},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1494120223131},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1494118823551},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1494120223107},{"_id":"themes/yilia/.git/logs/HEAD","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218550},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1494120223107},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1494120223107},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1494120223107},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1494120223107},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1494120223111},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1494120223119},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1494120223119},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1494120223119},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1494120223119},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1494120223119},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1494120223119},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1494120223119},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1494120223119},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1494120223119},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1494120223119},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1494120223123},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1494120223123},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1494120223127},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1494120223127},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1494120223127},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1494120223127},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1494120223127},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1494120223127},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1494120223127},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1494120223127},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1494120223127},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1494120223127},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1494120223131},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1494120223131},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1494120223127},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1494120223131},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1494120223131},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1494120223131},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1494120223131},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1494120223131},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1494120223131},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1494118823551},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1494118823551},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1494120223099},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1494118823551},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1494120223099},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1494118823551},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1494120223103},{"_id":"source/_posts/hello-world/hello-world.md","hash":"99fd04976870fb1e4add8f7fae8537847776ddf3","modified":1496055451639},{"_id":"source/_posts/Noreturn/Noreturn.md","hash":"211a934dc863c55153ef800036d5e47ebd333036","modified":1504689705558},{"_id":"source/_posts/lonely/lonely.md","hash":"50466f6bf1e7052580f4d7a91710eb3b995903a0","modified":1503501072463},{"_id":"source/_posts/my-life/my-life.md","hash":"908b77b4e5a521b6770030460c007ae731004a18","modified":1503578280768},{"_id":"source/_posts/binary/binary.md","hash":"9008e6c27e2d98c5c3423b110b0032be2c6c7ce5","modified":1503579583047},{"_id":"source/_posts/tail-recursion/tail_recursion.md","hash":"6f1528799794ae0a0397fa6f9dcd7d3253ee8271","modified":1503576030536},{"_id":"source/_posts/bug/bug.md","hash":"d613f37d7afc628c35354f917333b4fb7e0f371c","modified":1503581361428},{"_id":"source/_posts/gets-s/gets_s.md","hash":"efb227864f6d276a0db07364696d87a69f6318db","modified":1503577732291},{"_id":"source/_posts/programme-exercise/programme_exercise.md","hash":"cf8cde23a32330f7cd69ac4a5e0862bc02abfe3c","modified":1503576377587},{"_id":"source/_posts/null-character/null_character.md","hash":"19d88b6dfd56000dcf099dc112bf2e2cdf4d35f1","modified":1503580472858},{"_id":"themes/yilia/.git/refs/heads/master","hash":"891805485d22f9cbd7a1042d98f7953414f4c0fd","modified":1494120218550},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1494120223103},{"_id":"source/_posts/hello-byxc/hello-byxc.md","hash":"c1728745f6391439b59de35f9b98bded34f8338b","modified":1503566908236},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1494120223111},{"_id":"themes/yilia/.git/objects/pack/pack-34ce1806cd91d51f5b1d1f827d0021b0fcdfc362.idx","hash":"98ba278b2bd2a0baf4c76325542a2c9922d7cd45","modified":1494120217721},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1494120223111},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1494120223111},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1494120223115},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1494120223119},{"_id":"source/_posts/compilation-gcc/compilation-gcc.md","hash":"b0b16022b6dbdf6179166907e6b8453d58b30241","modified":1503578094673},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1494120223119},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1494120223119},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1494120223119},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1494120223099},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"1ba1d4a4663eae37b1a2b75c47dfdff4fb3cbf52","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1494120223103},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"7851d961ae172f521ba71e255fdc60f4ca0b45ed","modified":1494120223103},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1494120218522},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218550},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"30ffbf7ddea4175cb33bc0dc549d435f2b4716fd","modified":1494120218522},{"_id":"themes/yilia/source/img/logo.jpg","hash":"2a36910bbd0adf836ae5e7e89fb04ddfb82e540f","modified":1494123827891},{"_id":"themes/yilia/.git/objects/pack/pack-34ce1806cd91d51f5b1d1f827d0021b0fcdfc362.pack","hash":"023b4f59fd0e9f9fe92edb89711489870a07d85a","modified":1494120217697},{"_id":"public/content.json","hash":"8e39961eb5a87fb353c7e5ee2c29c9a218b4a948","modified":1504690356536},{"_id":"public/sitemap.xml","hash":"228a9bd96f1528debf702a4424937e9eb35f2d58","modified":1504690357831},{"_id":"public/2017/09/06/Noreturn/Noreturn/index.html","hash":"3f2fdb67443a5437bf43c51621f7a71e10aa34ba","modified":1504690358003},{"_id":"public/2017/08/23/binary/binary/index.html","hash":"778691d5fd33990dc8e339b9baad703a357d8e49","modified":1504690358003},{"_id":"public/2017/07/14/lonely/lonely/index.html","hash":"62d3912fc11930a1b8fc6a526b16b98d3f78539f","modified":1504690358003},{"_id":"public/2017/06/23/my-life/my-life/index.html","hash":"087b4571b848ba3e1712f4a0f6a400d6f78e2355","modified":1504690358004},{"_id":"public/2017/06/23/compilation-gcc/compilation-gcc/index.html","hash":"0baf09cd3def104fac1d6dc23ae9785409c412fc","modified":1504690358004},{"_id":"public/2017/05/29/gets-s/gets_s/index.html","hash":"f3176549bf0168293f8af84816f5dbe673ec29c1","modified":1504690358004},{"_id":"public/2017/05/29/null-character/null_character/index.html","hash":"432b803465ccb57e35555d6d40ff685c366b4bab","modified":1504690358005},{"_id":"public/2017/05/27/bug/bug/index.html","hash":"a514a6c040cc607de21fca08cdb3e5f1f8115693","modified":1504690358005},{"_id":"public/2017/05/26/programme-exercise/programme_exercise/index.html","hash":"23e9854f32cc619930a275b6d880dbe521a656ee","modified":1504690358005},{"_id":"public/2017/05/26/tail-recursion/tail_recursion/index.html","hash":"e69a588b4b1d5424f3219e87a7e36459ebed47e2","modified":1504690358005},{"_id":"public/2017/05/06/hello-byxc/hello-byxc/index.html","hash":"ea2c4db589dad7db9dbb9582eae0808c148463f8","modified":1504690358005},{"_id":"public/2017/05/06/hello-world/hello-world/index.html","hash":"8a7c709edb7ff24cac76e060f625aad188ff9f5f","modified":1504690358006},{"_id":"public/archives/index.html","hash":"571ad0bed76d0700cb6cdb06dbc3a7d33e5cba70","modified":1504690358012},{"_id":"public/archives/2017/index.html","hash":"d2f5743cd1d39adf1859534853c6160a8ef1b577","modified":1504690358013},{"_id":"public/archives/2017/05/index.html","hash":"210ba0eed9f1e63d870bb2ee5f40781734654e42","modified":1504690358013},{"_id":"public/archives/2017/06/index.html","hash":"39caedfe680754abf46d228065bade72bb0556f4","modified":1504690358013},{"_id":"public/archives/2017/07/index.html","hash":"e85b8c9a41a5f42a84872cdfe994953172ea2110","modified":1504690358013},{"_id":"public/archives/2017/08/index.html","hash":"b34e073fe56f880677f593c02d4bc931f97f8e22","modified":1504690358014},{"_id":"public/archives/2017/09/index.html","hash":"6ecbcbebbe6fb0b50d8c41a5e6115d5eca298d72","modified":1504690358014},{"_id":"public/index.html","hash":"54772c7b20a8ff5c4696a0856347cd90ea148287","modified":1504690358014},{"_id":"public/tags/Hello-World/index.html","hash":"de31dcc0331f6e7cc04390a4b85b81907799bcc0","modified":1504690358014},{"_id":"public/tags/Noreturn/index.html","hash":"7ec015f0d6e4a273fea4022483a2f5406fd45c3c","modified":1504690358015},{"_id":"public/tags/隨筆/index.html","hash":"2029a8fe2da1095d8379d934d478fabc800fc30e","modified":1504690358015},{"_id":"public/tags/life/index.html","hash":"bbae2afdca1994e44cffb610f3a76da6c4e86ac3","modified":1504690358015},{"_id":"public/tags/源碼-反碼-補碼/index.html","hash":"738c6ca380caa73f084aaad2eb2cf5f9c2209f66","modified":1504690358016},{"_id":"public/tags/尾遞歸/index.html","hash":"f9a67630326a3caba39543600e02980ff704e19b","modified":1504690358016},{"_id":"public/tags/gets-s/index.html","hash":"f50467988c95ce743815e41e74ef94ff67183baa","modified":1504690358016},{"_id":"public/tags/github/index.html","hash":"c02d316670d87809681b678db89d0871ec63ab98","modified":1504690358016},{"_id":"public/tags/空字符/index.html","hash":"46c8d41b695ef4b2c558a665b8d29d8b56e02826","modified":1504690358017},{"_id":"public/tags/hello/index.html","hash":"827ad6e2a84cba4ce3f5db4c9bb718b90f2e75e2","modified":1504690358017},{"_id":"public/tags/gcc/index.html","hash":"4c269099a3e9aa8004624908f7957a9559301514","modified":1504690358017},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1504690358043},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1504690358043},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1504690358043},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1504690358044},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1504690358044},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1504690358044},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1504690358044},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1504690358045},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1504690358045},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1504690358088},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1504690358088},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1504690358089},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1504690358089},{"_id":"public/img/logo.jpg","hash":"2a36910bbd0adf836ae5e7e89fb04ddfb82e540f","modified":1504690358280}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2017-05-06T05:14:52.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-05-06 13:14:52\ntags: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!--more-->\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world/hello-world","published":1,"updated":"2017-05-29T10:57:31.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts8zf0000t3lwfeg7bl3h","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><a id=\"more\"></a>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>"},{"title":"_Noreturn","date":"2017-09-06T09:01:08.000Z","_content":"\n# 屁大點事寫博客\n今天我學了 `_Noreturn` 這個函數說明符，書上的內容不多就兩段字：\n![書上的](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn2.png \"_Noreturn\")\n\n<!--more-->\n\n 準備寫個小程序測試一下。 結果還是出了 **bug**。\n\n代碼如下:\n``` c\n\t#include <stdio.h>\n\n\t_Noreturn void hello(double);\n\tint main(void)\n\t{\n    \thello(66.66);\n    \tprintf(\"empty\\n\");\n\t\n    \treturn 0;\n\t}\n\n\t_Noreturn void hello(double n)\n\t{\n    \tprintf(\"n = %f\\n\", n);\n\t}\n```\n\n我測試到的結果：\n![no_return1](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return1.png \"bug\")\n\n有兩個問題：\n第一個， 我沒有用 `return;` 卻有警告: 'noreturn' 函數返回了。\n第二個， 輸出的結果也出乎我意料， 輸出了兩次 `n` 的值。\n\n俗話說：“有問題，問度娘”。 我搜了一下 `_Noreturn` (C11)關鍵字，結果沒有找到。 後來去查了 [C語言參考手冊](http://zh.cppreference.com/w/c/language/_Noreturn \"cppreference\") 才知道問題出在哪。\n\n我截圖了：\n![cppreference](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn1.png \"_Noreturn\")\n解釋部分已經說的很清楚了。**`_Noreturn` 關鍵字出現于函數聲明中，并指定函數不會通過 `return` 語句或抵達函數體結尾而結束。若聲明了 `_Noreturn` 的函數返回了， 則行為未定義。**\n\n* * *\n\n可能我這種情況也是未定義(抵達函數結尾而結束)。\n以下是按照**C語言參考手冊**解釋的要求更改了代碼：\n``` c\n\t#include <stdio.h>\n\t#include <stdlib.h>     // for exit()\n\t\n\t_Noreturn void hello(double);\n\tint main(void)\n\t{\n\t\thello(66.66);\n\t\tprintf(\"empty\\n\");\n\t\n\t\treturn 0;\n\t}\n\t\n\t// 解釋中說到 _Noreturn 關鍵字出現在函數聲明中。\n\t// _Noreturn 在函數定義好像可有可無(本小白也不敢確定)， 去掉也完美編譯運行。\n\t_Noreturn void hello(double n)\n\t{\n    \tprintf(\"n = %f\\n\", n);\n    \texit(0);\n\t}\n```\n結果是我想要的， `gcc`不報警， 輸出也正常了。\n![no_return2](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return2.png \"ok\")\n\n## 結束語\n最后說一下： 多敲代碼， 不懂得地方多用搜索引擎， 實在找不到再去問人或發貼子。\n","source":"_posts/Noreturn/Noreturn.md","raw":"---\ntitle: _Noreturn\ndate: 2017-09-06 17:01:08\ntags: _Noreturn\n---\n\n# 屁大點事寫博客\n今天我學了 `_Noreturn` 這個函數說明符，書上的內容不多就兩段字：\n![書上的](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn2.png \"_Noreturn\")\n\n<!--more-->\n\n 準備寫個小程序測試一下。 結果還是出了 **bug**。\n\n代碼如下:\n``` c\n\t#include <stdio.h>\n\n\t_Noreturn void hello(double);\n\tint main(void)\n\t{\n    \thello(66.66);\n    \tprintf(\"empty\\n\");\n\t\n    \treturn 0;\n\t}\n\n\t_Noreturn void hello(double n)\n\t{\n    \tprintf(\"n = %f\\n\", n);\n\t}\n```\n\n我測試到的結果：\n![no_return1](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return1.png \"bug\")\n\n有兩個問題：\n第一個， 我沒有用 `return;` 卻有警告: 'noreturn' 函數返回了。\n第二個， 輸出的結果也出乎我意料， 輸出了兩次 `n` 的值。\n\n俗話說：“有問題，問度娘”。 我搜了一下 `_Noreturn` (C11)關鍵字，結果沒有找到。 後來去查了 [C語言參考手冊](http://zh.cppreference.com/w/c/language/_Noreturn \"cppreference\") 才知道問題出在哪。\n\n我截圖了：\n![cppreference](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn1.png \"_Noreturn\")\n解釋部分已經說的很清楚了。**`_Noreturn` 關鍵字出現于函數聲明中，并指定函數不會通過 `return` 語句或抵達函數體結尾而結束。若聲明了 `_Noreturn` 的函數返回了， 則行為未定義。**\n\n* * *\n\n可能我這種情況也是未定義(抵達函數結尾而結束)。\n以下是按照**C語言參考手冊**解釋的要求更改了代碼：\n``` c\n\t#include <stdio.h>\n\t#include <stdlib.h>     // for exit()\n\t\n\t_Noreturn void hello(double);\n\tint main(void)\n\t{\n\t\thello(66.66);\n\t\tprintf(\"empty\\n\");\n\t\n\t\treturn 0;\n\t}\n\t\n\t// 解釋中說到 _Noreturn 關鍵字出現在函數聲明中。\n\t// _Noreturn 在函數定義好像可有可無(本小白也不敢確定)， 去掉也完美編譯運行。\n\t_Noreturn void hello(double n)\n\t{\n    \tprintf(\"n = %f\\n\", n);\n    \texit(0);\n\t}\n```\n結果是我想要的， `gcc`不報警， 輸出也正常了。\n![no_return2](https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return2.png \"ok\")\n\n## 結束語\n最后說一下： 多敲代碼， 不懂得地方多用搜索引擎， 實在找不到再去問人或發貼子。\n","slug":"Noreturn/Noreturn","published":1,"updated":"2017-09-06T09:21:45.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts9520003t3lwt8k13ril","content":"<h1 id=\"屁大點事寫博客\"><a href=\"#屁大點事寫博客\" class=\"headerlink\" title=\"屁大點事寫博客\"></a>屁大點事寫博客</h1><p>今天我學了 <code>_Noreturn</code> 這個函數說明符，書上的內容不多就兩段字：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn2.png\" alt=\"書上的\" title=\"_Noreturn\"></p>\n<a id=\"more\"></a>\n<p> 準備寫個小程序測試一下。 結果還是出了 <strong>bug</strong>。</p>\n<p>代碼如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \thello(<span class=\"number\">66.66</span>);</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"empty\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">   \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"n = %f\\n\"</span>, n);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我測試到的結果：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return1.png\" alt=\"no_return1\" title=\"bug\"></p>\n<p>有兩個問題：<br>第一個， 我沒有用 <code>return;</code> 卻有警告: ‘noreturn’ 函數返回了。<br>第二個， 輸出的結果也出乎我意料， 輸出了兩次 <code>n</code> 的值。</p>\n<p>俗話說：“有問題，問度娘”。 我搜了一下 <code>_Noreturn</code> (C11)關鍵字，結果沒有找到。 後來去查了 <a href=\"http://zh.cppreference.com/w/c/language/_Noreturn\" title=\"cppreference\" target=\"_blank\" rel=\"external\">C語言參考手冊</a> 才知道問題出在哪。</p>\n<p>我截圖了：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn1.png\" alt=\"cppreference\" title=\"_Noreturn\"><br>解釋部分已經說的很清楚了。<strong><code>_Noreturn</code> 關鍵字出現于函數聲明中，并指定函數不會通過 <code>return</code> 語句或抵達函數體結尾而結束。若聲明了 <code>_Noreturn</code> 的函數返回了， 則行為未定義。</strong></p>\n<hr>\n<p>可能我這種情況也是未定義(抵達函數結尾而結束)。<br>以下是按照<strong>C語言參考手冊</strong>解釋的要求更改了代碼：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;     // for exit()</span></span></div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\thello(<span class=\"number\">66.66</span>);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"empty\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 解釋中說到 _Noreturn 關鍵字出現在函數聲明中。</span></div><div class=\"line\"><span class=\"comment\">// _Noreturn 在函數定義好像可有可無(本小白也不敢確定)， 去掉也完美編譯運行。</span></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"n = %f\\n\"</span>, n);</div><div class=\"line\">   \t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>結果是我想要的， <code>gcc</code>不報警， 輸出也正常了。<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return2.png\" alt=\"no_return2\" title=\"ok\"></p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>最后說一下： 多敲代碼， 不懂得地方多用搜索引擎， 實在找不到再去問人或發貼子。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"屁大點事寫博客\"><a href=\"#屁大點事寫博客\" class=\"headerlink\" title=\"屁大點事寫博客\"></a>屁大點事寫博客</h1><p>今天我學了 <code>_Noreturn</code> 這個函數說明符，書上的內容不多就兩段字：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn2.png\" alt=\"書上的\" title=\"_Noreturn\"></p>","more":"<p> 準備寫個小程序測試一下。 結果還是出了 <strong>bug</strong>。</p>\n<p>代碼如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \thello(<span class=\"number\">66.66</span>);</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"empty\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">   \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"n = %f\\n\"</span>, n);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我測試到的結果：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return1.png\" alt=\"no_return1\" title=\"bug\"></p>\n<p>有兩個問題：<br>第一個， 我沒有用 <code>return;</code> 卻有警告: ‘noreturn’ 函數返回了。<br>第二個， 輸出的結果也出乎我意料， 輸出了兩次 <code>n</code> 的值。</p>\n<p>俗話說：“有問題，問度娘”。 我搜了一下 <code>_Noreturn</code> (C11)關鍵字，結果沒有找到。 後來去查了 <a href=\"http://zh.cppreference.com/w/c/language/_Noreturn\" title=\"cppreference\" target=\"_blank\" rel=\"external\">C語言參考手冊</a> 才知道問題出在哪。</p>\n<p>我截圖了：<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/_Noreturn1.png\" alt=\"cppreference\" title=\"_Noreturn\"><br>解釋部分已經說的很清楚了。<strong><code>_Noreturn</code> 關鍵字出現于函數聲明中，并指定函數不會通過 <code>return</code> 語句或抵達函數體結尾而結束。若聲明了 <code>_Noreturn</code> 的函數返回了， 則行為未定義。</strong></p>\n<hr>\n<p>可能我這種情況也是未定義(抵達函數結尾而結束)。<br>以下是按照<strong>C語言參考手冊</strong>解釋的要求更改了代碼：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;     // for exit()</span></span></div><div class=\"line\"></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\thello(<span class=\"number\">66.66</span>);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"empty\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 解釋中說到 _Noreturn 關鍵字出現在函數聲明中。</span></div><div class=\"line\"><span class=\"comment\">// _Noreturn 在函數定義好像可有可無(本小白也不敢確定)， 去掉也完美編譯運行。</span></div><div class=\"line\">_<span class=\"function\">Noreturn <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"keyword\">double</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"n = %f\\n\"</span>, n);</div><div class=\"line\">   \t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>結果是我想要的， <code>gcc</code>不報警， 輸出也正常了。<br><img src=\"https://raw.githubusercontent.com/ByXc01/Blog-image/master/_Noreturn/no_return2.png\" alt=\"no_return2\" title=\"ok\"></p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>最后說一下： 多敲代碼， 不懂得地方多用搜索引擎， 實在找不到再去問人或發貼子。</p>"},{"title":"lonely","date":"2017-07-14T12:23:24.000Z","_content":"\n## bug ##\n最近一直在看**文件輸入/輸出**，對**流**和**緩衝區**還不是很理解。然後去網上找`setvbuf()`函數的詳細的用法，無意中看到一段代碼，如下:\n\n``` c\n    /* test1.c */\n    #include <stdio.h>\n    \n    char outbuf[512];               // 全局變量\n    int main(void)\n    {\n        setbuf(stdout, bufout);     // 把緩衝區與輸出流相連\n        \n        puts(\"This is a test of buffer output.\");\n        puts(outbuf);\n        \n        fflush(stdout);             // 感覺在這裏可有可無\n        puts(outbuf);               // 輸出\n        \n        return 0;\n    }\n```\n\n<!--more-->\n\n輸出如下:\n\n```\n    This is a test of buffer output.\n    This is a test of buffer output.\n    \n    This is a test of buffer output.\n    This is a test of buffer output.\n```\n\n程序很簡單，沒問題。於是我改了一下：\n\n``` c\n    /* test2.c */\n    #include <stdio.h>\n    int main(void)\n    {\n        char outbuf[512];\n    \n        setvbuf(stdout, outbuf, _IOFBF, 512);\n    \n        puts(\"This is a test of buffer output.\");\n        puts(outbuf);\n    \n        fflush(stdout);\n        puts(outbuf);\n    \n        return 0;\n    }\n```\n\n輸出如下:\n```\n    This is a test of buffer output.\n    This is a test of buffer output.\n    \n    ***********\n    *******\n```\n星號部分表示亂碼（或與**test1.c**輸出一樣，是不確定的)。這是爲什麼呢？後來我發現如果`outbuf`具有*靜態儲存期*時輸出卻與**test1.c**輸出一樣。自己能力不足去解釋這個問題（網上也沒有找到這樣的問題）， 在平時很活躍的羣問也沒人理。有人說在`clang`編譯與**test1.c**輸出一樣，我也測試在**tcc**編譯輸出也和**test1.c**一樣，我以爲是編譯器問題。\n\n## debug ##\n後來實在沒辦法， 又厚着臉皮去問**塵殤葉**前輩。。後來才知道：\n* * *\n因爲最後一個`puts(outbuf)`只是將`outbuf`的內容拷貝到`outbuf`512個字節中的某一處。當`main()`函數返回後，才會向終端打印字符。因爲`mian()`函數返回後會繼續執行一段c庫中的一些代碼。\n* * *\n\n那就是說`main(()`函數執行完，但程序並沒結束， 接着`main()`函數棧中的自動變量(*outbuf*)會被系統回收。如果被回收了很有可能亂碼或**Segmentation fault**。這就解釋了如果`outbuf`具有靜態儲存期(程序結束才被系統回收)就能像**test1.c**輸出一樣。如果在程序的末尾加上`fflush(stdout)`也能有同樣的效果。因把**緩衝區**刷新。將緩衝區中所有未寫入的數據被發送到`stdout`。其實也有關與編譯器， 不同的編譯器編譯出來的匯編。\n\n## 最後 ##\n謝謝**塵殤葉**的耐心解答。\n","source":"_posts/lonely/lonely.md","raw":"---\ntitle: lonely\ndate: 2017-07-14 20:23:24\ntags: 隨筆\n---\n\n## bug ##\n最近一直在看**文件輸入/輸出**，對**流**和**緩衝區**還不是很理解。然後去網上找`setvbuf()`函數的詳細的用法，無意中看到一段代碼，如下:\n\n``` c\n    /* test1.c */\n    #include <stdio.h>\n    \n    char outbuf[512];               // 全局變量\n    int main(void)\n    {\n        setbuf(stdout, bufout);     // 把緩衝區與輸出流相連\n        \n        puts(\"This is a test of buffer output.\");\n        puts(outbuf);\n        \n        fflush(stdout);             // 感覺在這裏可有可無\n        puts(outbuf);               // 輸出\n        \n        return 0;\n    }\n```\n\n<!--more-->\n\n輸出如下:\n\n```\n    This is a test of buffer output.\n    This is a test of buffer output.\n    \n    This is a test of buffer output.\n    This is a test of buffer output.\n```\n\n程序很簡單，沒問題。於是我改了一下：\n\n``` c\n    /* test2.c */\n    #include <stdio.h>\n    int main(void)\n    {\n        char outbuf[512];\n    \n        setvbuf(stdout, outbuf, _IOFBF, 512);\n    \n        puts(\"This is a test of buffer output.\");\n        puts(outbuf);\n    \n        fflush(stdout);\n        puts(outbuf);\n    \n        return 0;\n    }\n```\n\n輸出如下:\n```\n    This is a test of buffer output.\n    This is a test of buffer output.\n    \n    ***********\n    *******\n```\n星號部分表示亂碼（或與**test1.c**輸出一樣，是不確定的)。這是爲什麼呢？後來我發現如果`outbuf`具有*靜態儲存期*時輸出卻與**test1.c**輸出一樣。自己能力不足去解釋這個問題（網上也沒有找到這樣的問題）， 在平時很活躍的羣問也沒人理。有人說在`clang`編譯與**test1.c**輸出一樣，我也測試在**tcc**編譯輸出也和**test1.c**一樣，我以爲是編譯器問題。\n\n## debug ##\n後來實在沒辦法， 又厚着臉皮去問**塵殤葉**前輩。。後來才知道：\n* * *\n因爲最後一個`puts(outbuf)`只是將`outbuf`的內容拷貝到`outbuf`512個字節中的某一處。當`main()`函數返回後，才會向終端打印字符。因爲`mian()`函數返回後會繼續執行一段c庫中的一些代碼。\n* * *\n\n那就是說`main(()`函數執行完，但程序並沒結束， 接着`main()`函數棧中的自動變量(*outbuf*)會被系統回收。如果被回收了很有可能亂碼或**Segmentation fault**。這就解釋了如果`outbuf`具有靜態儲存期(程序結束才被系統回收)就能像**test1.c**輸出一樣。如果在程序的末尾加上`fflush(stdout)`也能有同樣的效果。因把**緩衝區**刷新。將緩衝區中所有未寫入的數據被發送到`stdout`。其實也有關與編譯器， 不同的編譯器編譯出來的匯編。\n\n## 最後 ##\n謝謝**塵殤葉**的耐心解答。\n","slug":"lonely/lonely","published":1,"updated":"2017-08-23T15:11:12.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts95f0004t3lw073644qx","content":"<h2 id=\"bug\"><a href=\"#bug\" class=\"headerlink\" title=\"bug\"></a>bug</h2><p>最近一直在看<strong>文件輸入/輸出</strong>，對<strong>流</strong>和<strong>緩衝區</strong>還不是很理解。然後去網上找<code>setvbuf()</code>函數的詳細的用法，無意中看到一段代碼，如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* test1.c */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> outbuf[<span class=\"number\">512</span>];               <span class=\"comment\">// 全局變量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    setbuf(<span class=\"built_in\">stdout</span>, bufout);     <span class=\"comment\">// 把緩衝區與輸出流相連</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"This is a test of buffer output.\"</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\">    </div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);             <span class=\"comment\">// 感覺在這裏可有可無</span></div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);               <span class=\"comment\">// 輸出</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>輸出如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\"></div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div></pre></td></tr></table></figure>\n<p>程序很簡單，沒問題。於是我改了一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* test2.c */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> outbuf[<span class=\"number\">512</span>];</div><div class=\"line\"></div><div class=\"line\">    setvbuf(<span class=\"built_in\">stdout</span>, outbuf, _IOFBF, <span class=\"number\">512</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"This is a test of buffer output.\"</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\"></div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>輸出如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\"></div><div class=\"line\">***********</div><div class=\"line\">*******</div></pre></td></tr></table></figure></p>\n<p>星號部分表示亂碼（或與<strong>test1.c</strong>輸出一樣，是不確定的)。這是爲什麼呢？後來我發現如果<code>outbuf</code>具有<em>靜態儲存期</em>時輸出卻與<strong>test1.c</strong>輸出一樣。自己能力不足去解釋這個問題（網上也沒有找到這樣的問題）， 在平時很活躍的羣問也沒人理。有人說在<code>clang</code>編譯與<strong>test1.c</strong>輸出一樣，我也測試在<strong>tcc</strong>編譯輸出也和<strong>test1.c</strong>一樣，我以爲是編譯器問題。</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>後來實在沒辦法， 又厚着臉皮去問<strong>塵殤葉</strong>前輩。。後來才知道：</p>\n<hr>\n<p>因爲最後一個<code>puts(outbuf)</code>只是將<code>outbuf</code>的內容拷貝到<code>outbuf</code>512個字節中的某一處。當<code>main()</code>函數返回後，才會向終端打印字符。因爲<code>mian()</code>函數返回後會繼續執行一段c庫中的一些代碼。</p>\n<hr>\n<p>那就是說<code>main(()</code>函數執行完，但程序並沒結束， 接着<code>main()</code>函數棧中的自動變量(<em>outbuf</em>)會被系統回收。如果被回收了很有可能亂碼或<strong>Segmentation fault</strong>。這就解釋了如果<code>outbuf</code>具有靜態儲存期(程序結束才被系統回收)就能像<strong>test1.c</strong>輸出一樣。如果在程序的末尾加上<code>fflush(stdout)</code>也能有同樣的效果。因把<strong>緩衝區</strong>刷新。將緩衝區中所有未寫入的數據被發送到<code>stdout</code>。其實也有關與編譯器， 不同的編譯器編譯出來的匯編。</p>\n<h2 id=\"最後\"><a href=\"#最後\" class=\"headerlink\" title=\"最後\"></a>最後</h2><p>謝謝<strong>塵殤葉</strong>的耐心解答。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"bug\"><a href=\"#bug\" class=\"headerlink\" title=\"bug\"></a>bug</h2><p>最近一直在看<strong>文件輸入/輸出</strong>，對<strong>流</strong>和<strong>緩衝區</strong>還不是很理解。然後去網上找<code>setvbuf()</code>函數的詳細的用法，無意中看到一段代碼，如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* test1.c */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">char</span> outbuf[<span class=\"number\">512</span>];               <span class=\"comment\">// 全局變量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    setbuf(<span class=\"built_in\">stdout</span>, bufout);     <span class=\"comment\">// 把緩衝區與輸出流相連</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"This is a test of buffer output.\"</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\">    </div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);             <span class=\"comment\">// 感覺在這裏可有可無</span></div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);               <span class=\"comment\">// 輸出</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>輸出如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\"></div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div></pre></td></tr></table></figure>\n<p>程序很簡單，沒問題。於是我改了一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* test2.c */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> outbuf[<span class=\"number\">512</span>];</div><div class=\"line\"></div><div class=\"line\">    setvbuf(<span class=\"built_in\">stdout</span>, outbuf, _IOFBF, <span class=\"number\">512</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"This is a test of buffer output.\"</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\"></div><div class=\"line\">    fflush(<span class=\"built_in\">stdout</span>);</div><div class=\"line\">    <span class=\"built_in\">puts</span>(outbuf);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>輸出如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">This is a test of buffer output.</div><div class=\"line\">This is a test of buffer output.</div><div class=\"line\"></div><div class=\"line\">***********</div><div class=\"line\">*******</div></pre></td></tr></table></figure></p>\n<p>星號部分表示亂碼（或與<strong>test1.c</strong>輸出一樣，是不確定的)。這是爲什麼呢？後來我發現如果<code>outbuf</code>具有<em>靜態儲存期</em>時輸出卻與<strong>test1.c</strong>輸出一樣。自己能力不足去解釋這個問題（網上也沒有找到這樣的問題）， 在平時很活躍的羣問也沒人理。有人說在<code>clang</code>編譯與<strong>test1.c</strong>輸出一樣，我也測試在<strong>tcc</strong>編譯輸出也和<strong>test1.c</strong>一樣，我以爲是編譯器問題。</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>後來實在沒辦法， 又厚着臉皮去問<strong>塵殤葉</strong>前輩。。後來才知道：</p>\n<hr>\n<p>因爲最後一個<code>puts(outbuf)</code>只是將<code>outbuf</code>的內容拷貝到<code>outbuf</code>512個字節中的某一處。當<code>main()</code>函數返回後，才會向終端打印字符。因爲<code>mian()</code>函數返回後會繼續執行一段c庫中的一些代碼。</p>\n<hr>\n<p>那就是說<code>main(()</code>函數執行完，但程序並沒結束， 接着<code>main()</code>函數棧中的自動變量(<em>outbuf</em>)會被系統回收。如果被回收了很有可能亂碼或<strong>Segmentation fault</strong>。這就解釋了如果<code>outbuf</code>具有靜態儲存期(程序結束才被系統回收)就能像<strong>test1.c</strong>輸出一樣。如果在程序的末尾加上<code>fflush(stdout)</code>也能有同樣的效果。因把<strong>緩衝區</strong>刷新。將緩衝區中所有未寫入的數據被發送到<code>stdout</code>。其實也有關與編譯器， 不同的編譯器編譯出來的匯編。</p>\n<h2 id=\"最後\"><a href=\"#最後\" class=\"headerlink\" title=\"最後\"></a>最後</h2><p>謝謝<strong>塵殤葉</strong>的耐心解答。</p>"},{"title":"My Life","date":"2017-06-23T11:49:54.000Z","_content":"\n## 開場白\n>>> 爲什麼會有這篇文章？\n\n>> 這是我初中沒學好，畢業後幾年的後果。\n\n> 真後悔初中沒好好學， 上個高中選個理科， 考個大學讀真正的**軟件工程**。 \n\n<!--more-->\n\n## There are no regrets in life, just lessons.\n人生沒有後悔， 只有教訓 \n\n\n## 能上高中就不要去技校\n初中畢業幾年， 見識過不少人， 經歷過不少事， 進過不少坑。 打過幾年雑工： 發過傳單， 送過外賣， 進過工廠， 做過服務員。期間一直對編程很感興趣， 堅持到了現在， 只學到了一些皮毛。 然而一年前懷着我的編程夢， 說服了我老爸讓繼續讀書。 誰知這是噩夢的開始， 理想與現實的區別， 各種坑······（此處省略十萬字） 一年後的今天我打算不讀了。 \n\n## 跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”\n你們也不用勸我了， 我已經決定。 最後一次機會， 我會回老家自學一年。看一下會有什麼成果。我知道我英語和數學一點都不會， 學起來會更吃力。 但這都是我自找了， 怪不了誰。 我也不知我哪來的信心。 現在只想做我想做的事， 做我想做的人， 過我想過的生活。這不是YY。\n\n## 學習目標\n感謝塵殤葉前輩的建議。 首先我把《**c primer plus**》學完， 然後可能再去看一下《**c 專家編程**》、《**c 和指針**》還有《**c 陷阱和缺陷**》》， 有必要學一下匯編， 再學一下單片機和 `linux` 系統 `c` 編程。 雖然都是偏底層的， 但有空也要學一下 `c++` 畢竟去年雙十一的時候買了兩本書 《**c primer plus**》 和 《**c++ primer plus**》。什麼《**算法導論**》、《**數據結構**》、《**離散數學**》、《**高等數學**》 這些好像很難，先放一放。\n\n![塵殤葉](https://github.com/ByXc01/Blog-image/raw/master/my_life/yeshangchen.png \"塵殤葉\");\n## 一年後再見\n現在逐漸從 `Windows` 轉到 `Linux`。 博客已備份到 `github`。 不用再在虛擬機耍， 直接上物理機。博客的話可能也沒時間更了，而且在老家也沒網。就當閉關修煉。\n","source":"_posts/my-life/my-life.md","raw":"---\ntitle: My Life\ndate: 2017-06-23 19:49:54\ntags: life\n---\n\n## 開場白\n>>> 爲什麼會有這篇文章？\n\n>> 這是我初中沒學好，畢業後幾年的後果。\n\n> 真後悔初中沒好好學， 上個高中選個理科， 考個大學讀真正的**軟件工程**。 \n\n<!--more-->\n\n## There are no regrets in life, just lessons.\n人生沒有後悔， 只有教訓 \n\n\n## 能上高中就不要去技校\n初中畢業幾年， 見識過不少人， 經歷過不少事， 進過不少坑。 打過幾年雑工： 發過傳單， 送過外賣， 進過工廠， 做過服務員。期間一直對編程很感興趣， 堅持到了現在， 只學到了一些皮毛。 然而一年前懷着我的編程夢， 說服了我老爸讓繼續讀書。 誰知這是噩夢的開始， 理想與現實的區別， 各種坑······（此處省略十萬字） 一年後的今天我打算不讀了。 \n\n## 跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”\n你們也不用勸我了， 我已經決定。 最後一次機會， 我會回老家自學一年。看一下會有什麼成果。我知道我英語和數學一點都不會， 學起來會更吃力。 但這都是我自找了， 怪不了誰。 我也不知我哪來的信心。 現在只想做我想做的事， 做我想做的人， 過我想過的生活。這不是YY。\n\n## 學習目標\n感謝塵殤葉前輩的建議。 首先我把《**c primer plus**》學完， 然後可能再去看一下《**c 專家編程**》、《**c 和指針**》還有《**c 陷阱和缺陷**》》， 有必要學一下匯編， 再學一下單片機和 `linux` 系統 `c` 編程。 雖然都是偏底層的， 但有空也要學一下 `c++` 畢竟去年雙十一的時候買了兩本書 《**c primer plus**》 和 《**c++ primer plus**》。什麼《**算法導論**》、《**數據結構**》、《**離散數學**》、《**高等數學**》 這些好像很難，先放一放。\n\n![塵殤葉](https://github.com/ByXc01/Blog-image/raw/master/my_life/yeshangchen.png \"塵殤葉\");\n## 一年後再見\n現在逐漸從 `Windows` 轉到 `Linux`。 博客已備份到 `github`。 不用再在虛擬機耍， 直接上物理機。博客的話可能也沒時間更了，而且在老家也沒網。就當閉關修煉。\n","slug":"my-life/my-life","published":1,"updated":"2017-08-24T12:38:00.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts95n0006t3lwcwcscknf","content":"<h2 id=\"開場白\"><a href=\"#開場白\" class=\"headerlink\" title=\"開場白\"></a>開場白</h2><blockquote>\n<blockquote>\n<blockquote>\n<p>爲什麼會有這篇文章？</p>\n</blockquote>\n<p>這是我初中沒學好，畢業後幾年的後果。</p>\n</blockquote>\n<p>真後悔初中沒好好學， 上個高中選個理科， 考個大學讀真正的<strong>軟件工程</strong>。 </p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"There-are-no-regrets-in-life-just-lessons\"><a href=\"#There-are-no-regrets-in-life-just-lessons\" class=\"headerlink\" title=\"There are no regrets in life, just lessons.\"></a>There are no regrets in life, just lessons.</h2><p>人生沒有後悔， 只有教訓 </p>\n<h2 id=\"能上高中就不要去技校\"><a href=\"#能上高中就不要去技校\" class=\"headerlink\" title=\"能上高中就不要去技校\"></a>能上高中就不要去技校</h2><p>初中畢業幾年， 見識過不少人， 經歷過不少事， 進過不少坑。 打過幾年雑工： 發過傳單， 送過外賣， 進過工廠， 做過服務員。期間一直對編程很感興趣， 堅持到了現在， 只學到了一些皮毛。 然而一年前懷着我的編程夢， 說服了我老爸讓繼續讀書。 誰知這是噩夢的開始， 理想與現實的區別， 各種坑······（此處省略十萬字） 一年後的今天我打算不讀了。 </p>\n<h2 id=\"跟我家人和關心我朋友說聲：-“對不起，又讓你們失望了。”\"><a href=\"#跟我家人和關心我朋友說聲：-“對不起，又讓你們失望了。”\" class=\"headerlink\" title=\"跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”\"></a>跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”</h2><p>你們也不用勸我了， 我已經決定。 最後一次機會， 我會回老家自學一年。看一下會有什麼成果。我知道我英語和數學一點都不會， 學起來會更吃力。 但這都是我自找了， 怪不了誰。 我也不知我哪來的信心。 現在只想做我想做的事， 做我想做的人， 過我想過的生活。這不是YY。</p>\n<h2 id=\"學習目標\"><a href=\"#學習目標\" class=\"headerlink\" title=\"學習目標\"></a>學習目標</h2><p>感謝塵殤葉前輩的建議。 首先我把《<strong>c primer plus</strong>》學完， 然後可能再去看一下《<strong>c 專家編程</strong>》、《<strong>c 和指針</strong>》還有《<strong>c 陷阱和缺陷</strong>》》， 有必要學一下匯編， 再學一下單片機和 <code>linux</code> 系統 <code>c</code> 編程。 雖然都是偏底層的， 但有空也要學一下 <code>c++</code> 畢竟去年雙十一的時候買了兩本書 《<strong>c primer plus</strong>》 和 《<strong>c++ primer plus</strong>》。什麼《<strong>算法導論</strong>》、《<strong>數據結構</strong>》、《<strong>離散數學</strong>》、《<strong>高等數學</strong>》 這些好像很難，先放一放。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/my_life/yeshangchen.png\" alt=\"塵殤葉\" title=\"塵殤葉\">;</p>\n<h2 id=\"一年後再見\"><a href=\"#一年後再見\" class=\"headerlink\" title=\"一年後再見\"></a>一年後再見</h2><p>現在逐漸從 <code>Windows</code> 轉到 <code>Linux</code>。 博客已備份到 <code>github</code>。 不用再在虛擬機耍， 直接上物理機。博客的話可能也沒時間更了，而且在老家也沒網。就當閉關修煉。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"開場白\"><a href=\"#開場白\" class=\"headerlink\" title=\"開場白\"></a>開場白</h2><blockquote>\n<blockquote>\n<blockquote>\n<p>爲什麼會有這篇文章？</p>\n</blockquote>\n<p>這是我初中沒學好，畢業後幾年的後果。</p>\n</blockquote>\n<p>真後悔初中沒好好學， 上個高中選個理科， 考個大學讀真正的<strong>軟件工程</strong>。 </p>\n</blockquote>","more":"<h2 id=\"There-are-no-regrets-in-life-just-lessons\"><a href=\"#There-are-no-regrets-in-life-just-lessons\" class=\"headerlink\" title=\"There are no regrets in life, just lessons.\"></a>There are no regrets in life, just lessons.</h2><p>人生沒有後悔， 只有教訓 </p>\n<h2 id=\"能上高中就不要去技校\"><a href=\"#能上高中就不要去技校\" class=\"headerlink\" title=\"能上高中就不要去技校\"></a>能上高中就不要去技校</h2><p>初中畢業幾年， 見識過不少人， 經歷過不少事， 進過不少坑。 打過幾年雑工： 發過傳單， 送過外賣， 進過工廠， 做過服務員。期間一直對編程很感興趣， 堅持到了現在， 只學到了一些皮毛。 然而一年前懷着我的編程夢， 說服了我老爸讓繼續讀書。 誰知這是噩夢的開始， 理想與現實的區別， 各種坑······（此處省略十萬字） 一年後的今天我打算不讀了。 </p>\n<h2 id=\"跟我家人和關心我朋友說聲：-“對不起，又讓你們失望了。”\"><a href=\"#跟我家人和關心我朋友說聲：-“對不起，又讓你們失望了。”\" class=\"headerlink\" title=\"跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”\"></a>跟我家人和關心我朋友說聲： “對不起，又讓你們失望了。”</h2><p>你們也不用勸我了， 我已經決定。 最後一次機會， 我會回老家自學一年。看一下會有什麼成果。我知道我英語和數學一點都不會， 學起來會更吃力。 但這都是我自找了， 怪不了誰。 我也不知我哪來的信心。 現在只想做我想做的事， 做我想做的人， 過我想過的生活。這不是YY。</p>\n<h2 id=\"學習目標\"><a href=\"#學習目標\" class=\"headerlink\" title=\"學習目標\"></a>學習目標</h2><p>感謝塵殤葉前輩的建議。 首先我把《<strong>c primer plus</strong>》學完， 然後可能再去看一下《<strong>c 專家編程</strong>》、《<strong>c 和指針</strong>》還有《<strong>c 陷阱和缺陷</strong>》》， 有必要學一下匯編， 再學一下單片機和 <code>linux</code> 系統 <code>c</code> 編程。 雖然都是偏底層的， 但有空也要學一下 <code>c++</code> 畢竟去年雙十一的時候買了兩本書 《<strong>c primer plus</strong>》 和 《<strong>c++ primer plus</strong>》。什麼《<strong>算法導論</strong>》、《<strong>數據結構</strong>》、《<strong>離散數學</strong>》、《<strong>高等數學</strong>》 這些好像很難，先放一放。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/my_life/yeshangchen.png\" alt=\"塵殤葉\" title=\"塵殤葉\">;</p>\n<h2 id=\"一年後再見\"><a href=\"#一年後再見\" class=\"headerlink\" title=\"一年後再見\"></a>一年後再見</h2><p>現在逐漸從 <code>Windows</code> 轉到 <code>Linux</code>。 博客已備份到 <code>github</code>。 不用再在虛擬機耍， 直接上物理機。博客的話可能也沒時間更了，而且在老家也沒網。就當閉關修煉。</p>"},{"title":"binary","date":"2017-08-23T12:27:57.000Z","_content":"# 原碼、反碼、補碼\n此博客部分轉載 [计算机为什么选用二进制补码（1）---原码、反码、补码](http://blog.csdn.net/hittata/article/details/9108323 \"千年的塔\")\n\n## 1.總的概念\n(1): 數在計算機中是以二進制形式表示的；\n(2): 數分為有符號數和無符號數；\n(3): 原碼、反碼、補碼都是有定點數的表示方法；\n(4): 無符號數全部按正數處理；\n(5): 一個有符號定點數的最高位，0是正，1是負；\n<!--more-->\n\n## 2.反碼，補碼定義\n**正數：**\n原碼 = 反碼 = 補碼\n\n**負數：**\n原碼；\n反碼 = 其原碼除符號位之外的各位求反；\n補碼 = 反碼 + 1 （如果 + 1 之後又進位的， 要一直往前進位， 包括符號位；\n\n## 3.運算示例\n\n(這裡按照一字節(byte)八位(Bit)表示)\n正零： 0000 0000\n負零： 1000 0000\n其實這兩個數都是 0， 但它們的原碼卻有不同的表示。\n但它們的補碼是一樣的， 都是 0000 0000。\n**特別注意，如果 +1 之後有進位的， 要一直往前進位， 包括符號位!(這和反碼不同)**\n\n[1000 0000]補\n= [1000 0000]反 + 1\n= 1111 1111 + 1\n= (1)0000 0000\n= 0000 0000（最高位溢出了，符號位變成了0)\n\n### 提一下補碼的兩個特性\n**(1): 負補碼轉原碼的方法是： 取補碼的反碼+1；**\n**(2): 求補碼相反數的方法是： 反轉每一位(包括符號位，即0變1，1變0），然後加1。)；**\n例1： \n-1 \n（1000 0001）原碼\n（1111 1110）反碼\n（1111 1111）補碼\n求（1111 1111）補碼表示的原碼。\n（1111 1111）補碼\n（1000 0000）反碼\n（1000 0001）原碼\n\n例2：\n由上面可知 -1 的補碼是 1111 1111，求 1111 1111 補碼的相反數。\n（1111 1111）補碼\n（0000 0000）取反\n（0000 0001）+1\n\n### 原碼和反碼的0都有兩種表示\n+0 = 0000 0001\n-0 = 1000 0001\n因此原碼和反碼表示的範圍都是是-127 ~ +127。\n**但補碼的0只有一種表示，即 0000 0000。那麼補碼的表示範圍是-128 ~ +127**\n當時本人一直是沒想明白：為什麼可以表示多一位，而且還是-128。\n於是找到以下答案：\n既然補碼表示0的是 0000 0000 那麼就多出一位，即: 1000 0000。其實這是一個規定， 這個補碼表示的是 -128。況且[1000 0000]也沒有相對應的原碼。\n\n### 舉個栗子\n\n+100 0110(正數)\n原碼: 0100 0110\n反碼: 0100 0110\n補碼: 0100 0110\n\n-100 0110(負數)\n原碼： 1100 0110\n反碼： 1011 1001\n補碼： 1011 1010\n\n## 4.幾個特殊定義：\n(1): n位補碼能表示的範圍：有符號數是 -2^(n-1) 到 2^(n-1)-1。無符號是 0 到 2^(n-1)。\n(2): -128 的補碼是 1000 0000, -128 + 1 = -127，(-127)補 = 1000 0001 = 1000 0000 + 0000 0001 符合運算規則。\n(3): 0 的補碼 0000 0000\n\n## 既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\n其實也沒有學會，因為原碼、反碼和補碼都有公式。反正我是沒看明白。以前老師也沒講公式上來就是說：原碼符號位0表示正，1表示負。反碼就是除了符號位不變， 1變0,0變1。補碼就是反碼+1。\n\n### 疑惑\n本人學C語言是看書入門的， c primer plus是一本很好的入門書。書中第六章的“6.2.1 終止 while 循環”有個問題就是一個變量自減特定次后會從負數變成正數，讓後終止循環。\n![c primer plus](https://github.com/ByXc01/Blog-image/raw/master/binary/while.png \"while\")\n測試了一下， 果真如此。代碼如下：\n``` c\n    // while.c\n    #include <stdio.h>\n    int main(void)\n    {\n        signed char index = 1;      // 使用 char ， 使用其它整數類型迭代次數較多。\n\n        while (--index < 5)\n            printf(\"%d \", index);\n        printf(\"\\n\\nlast value: %d\\n\", index);\n\n        return 0;\n    }\n```\n輸出如下：\n![program](https://github.com/ByXc01/Blog-image/raw/master/binary/while2.png \"while test\")\n**很明顯迭代的退出`index`的值是 127。 127 < 5 表達式的值為0。`signed char`一字節（八位），從左往右第一位是符號位。負數用補碼存儲。範圍是 -2^(8-1) ~ 2^(8-1)-1， 即 -128 ~ 127。**\n很好， 有點眉頭了。\n\n## 溢出\n下面我們來看一段代碼:\n``` c\n    // limit.c\n    #include <stdio.h>\n    int main(void)\n    {\n        signed char num = -1;\n        printf(\"signed: %hhd, unsigned: %hhu\\n\", num, num);\n\n        return 0;\n    }\n```\n輸出如下：\n![limit](https://github.com/ByXc01/Blog-image/raw/master/binary/limit.png \"ByXc\")\n由例1已知， -1 的補碼是 1111 1111。如果是按有符號解析的話，第一位是符號位（為負），其餘是數值位。所以正是-1。但如果是無符號為的話，八位全是數值位，即是255。\n還沒完咧， 繼續往下看：\n``` c\n    // limit2.c\n    #include <stdio.h>\n    #include <limits.h>     // 提供明示常量\n\n    #define UCHAR_MIN 0     // 因為無符號最小值就是0， limits.h 頭文件里沒有\n    #define UINT_MIN 0\n\n    int main(void)\n    {\n        printf(\"UCHAR_MAX = %hhu, UCHAR_MAX + 1 = %hhu\\n\", UCHAR_MAX, UCHAR_MAX + 1);\n        printf(\"UCHAR_MIN = %hhu, UCHAR_MIN - 1 = %hhu\\n\", UCHAR_MIN, UCHAR_MIN - 1);\n        printf(\"CHAR_MAX = %hhd, CHAR_MAX + 1 = %hhd\\n\", CHAR_MAX, CHAR_MAX + 1);\n        printf(\"CHAR_MIN = %hhd, CHAR_MIN - 1 = %hhd\\n\", CHAR_MIN, CHAR_MIN - 1);\n        putchar('\\n');\n\n        printf(\"UINT_MAX = %u, UINT_MAX + 1 = %u\\n\", UINT_MAX, UINT_MAX + 1);\n        printf(\"UINT_MIN = %u, UINT_MIN - 1 = %u\\n\", UINT_MIN, UINT_MIN - 1);\n        printf(\"INT_MAX = %d, INT_MAX + 1 = %d\\n\", INT_MAX, INT_MAX + 1);\n        printf(\"INT_MIN = %d, INT_MIN - 1 = %d\\n\", INT_MIN, INT_MAX - 1);\n\n        return 0;\n    }\n```\n輸出以下：\n![limit2](https://github.com/ByXc01/Blog-image/raw/master/binary/limit2.png \"ByXc\")\n好吧，終於警告了。\n我只把`char`類型的解釋一下， 其它的整數類型也一樣，就不作重複解釋了。以下是本人的瞎解釋，歡迎指出錯誤。\n\n**1.正溢出。 八位無符號最大值是255。**\n      1111 1111 [+255]\n\\+    0000 0001 [+1]\n= (1) 0000 0000 [0]\n符號位溢出。\n\n**2.負溢出。八位無符號。**\n     0000 0000 [0]\n\\-    0000 0001 [1]\n=    1111 1111 [+255]\n\n**3.正溢出。有符號八位最大值是127。**\n   0111 1111 [+127]\n\\+ 0000 0001 [+1]\n=  1000 0000 (補碼）[-128]\n符號位溢出\n\n**4.負溢出。有符號八位最小值是-128。補碼為: 1000 0000。**\n   1000 0000 （補碼)[-128]\n\\-  0000 0001 [+1]\n=  0111 1111 [+127]\n\n\npostscript:以上的代碼輸出可能不是所有的機器上都是一樣。因為本人剛看到了十五章，將現所學的進行解答。\n\n## 最後\n唉，不說了， 繼續研究二進制浮點數。\n","source":"_posts/binary/binary.md","raw":"---\ntitle: binary\ndate: 2017-08-23 20:27:57\ntags: 源碼 反碼 補碼\n---\n# 原碼、反碼、補碼\n此博客部分轉載 [计算机为什么选用二进制补码（1）---原码、反码、补码](http://blog.csdn.net/hittata/article/details/9108323 \"千年的塔\")\n\n## 1.總的概念\n(1): 數在計算機中是以二進制形式表示的；\n(2): 數分為有符號數和無符號數；\n(3): 原碼、反碼、補碼都是有定點數的表示方法；\n(4): 無符號數全部按正數處理；\n(5): 一個有符號定點數的最高位，0是正，1是負；\n<!--more-->\n\n## 2.反碼，補碼定義\n**正數：**\n原碼 = 反碼 = 補碼\n\n**負數：**\n原碼；\n反碼 = 其原碼除符號位之外的各位求反；\n補碼 = 反碼 + 1 （如果 + 1 之後又進位的， 要一直往前進位， 包括符號位；\n\n## 3.運算示例\n\n(這裡按照一字節(byte)八位(Bit)表示)\n正零： 0000 0000\n負零： 1000 0000\n其實這兩個數都是 0， 但它們的原碼卻有不同的表示。\n但它們的補碼是一樣的， 都是 0000 0000。\n**特別注意，如果 +1 之後有進位的， 要一直往前進位， 包括符號位!(這和反碼不同)**\n\n[1000 0000]補\n= [1000 0000]反 + 1\n= 1111 1111 + 1\n= (1)0000 0000\n= 0000 0000（最高位溢出了，符號位變成了0)\n\n### 提一下補碼的兩個特性\n**(1): 負補碼轉原碼的方法是： 取補碼的反碼+1；**\n**(2): 求補碼相反數的方法是： 反轉每一位(包括符號位，即0變1，1變0），然後加1。)；**\n例1： \n-1 \n（1000 0001）原碼\n（1111 1110）反碼\n（1111 1111）補碼\n求（1111 1111）補碼表示的原碼。\n（1111 1111）補碼\n（1000 0000）反碼\n（1000 0001）原碼\n\n例2：\n由上面可知 -1 的補碼是 1111 1111，求 1111 1111 補碼的相反數。\n（1111 1111）補碼\n（0000 0000）取反\n（0000 0001）+1\n\n### 原碼和反碼的0都有兩種表示\n+0 = 0000 0001\n-0 = 1000 0001\n因此原碼和反碼表示的範圍都是是-127 ~ +127。\n**但補碼的0只有一種表示，即 0000 0000。那麼補碼的表示範圍是-128 ~ +127**\n當時本人一直是沒想明白：為什麼可以表示多一位，而且還是-128。\n於是找到以下答案：\n既然補碼表示0的是 0000 0000 那麼就多出一位，即: 1000 0000。其實這是一個規定， 這個補碼表示的是 -128。況且[1000 0000]也沒有相對應的原碼。\n\n### 舉個栗子\n\n+100 0110(正數)\n原碼: 0100 0110\n反碼: 0100 0110\n補碼: 0100 0110\n\n-100 0110(負數)\n原碼： 1100 0110\n反碼： 1011 1001\n補碼： 1011 1010\n\n## 4.幾個特殊定義：\n(1): n位補碼能表示的範圍：有符號數是 -2^(n-1) 到 2^(n-1)-1。無符號是 0 到 2^(n-1)。\n(2): -128 的補碼是 1000 0000, -128 + 1 = -127，(-127)補 = 1000 0001 = 1000 0000 + 0000 0001 符合運算規則。\n(3): 0 的補碼 0000 0000\n\n## 既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\n其實也沒有學會，因為原碼、反碼和補碼都有公式。反正我是沒看明白。以前老師也沒講公式上來就是說：原碼符號位0表示正，1表示負。反碼就是除了符號位不變， 1變0,0變1。補碼就是反碼+1。\n\n### 疑惑\n本人學C語言是看書入門的， c primer plus是一本很好的入門書。書中第六章的“6.2.1 終止 while 循環”有個問題就是一個變量自減特定次后會從負數變成正數，讓後終止循環。\n![c primer plus](https://github.com/ByXc01/Blog-image/raw/master/binary/while.png \"while\")\n測試了一下， 果真如此。代碼如下：\n``` c\n    // while.c\n    #include <stdio.h>\n    int main(void)\n    {\n        signed char index = 1;      // 使用 char ， 使用其它整數類型迭代次數較多。\n\n        while (--index < 5)\n            printf(\"%d \", index);\n        printf(\"\\n\\nlast value: %d\\n\", index);\n\n        return 0;\n    }\n```\n輸出如下：\n![program](https://github.com/ByXc01/Blog-image/raw/master/binary/while2.png \"while test\")\n**很明顯迭代的退出`index`的值是 127。 127 < 5 表達式的值為0。`signed char`一字節（八位），從左往右第一位是符號位。負數用補碼存儲。範圍是 -2^(8-1) ~ 2^(8-1)-1， 即 -128 ~ 127。**\n很好， 有點眉頭了。\n\n## 溢出\n下面我們來看一段代碼:\n``` c\n    // limit.c\n    #include <stdio.h>\n    int main(void)\n    {\n        signed char num = -1;\n        printf(\"signed: %hhd, unsigned: %hhu\\n\", num, num);\n\n        return 0;\n    }\n```\n輸出如下：\n![limit](https://github.com/ByXc01/Blog-image/raw/master/binary/limit.png \"ByXc\")\n由例1已知， -1 的補碼是 1111 1111。如果是按有符號解析的話，第一位是符號位（為負），其餘是數值位。所以正是-1。但如果是無符號為的話，八位全是數值位，即是255。\n還沒完咧， 繼續往下看：\n``` c\n    // limit2.c\n    #include <stdio.h>\n    #include <limits.h>     // 提供明示常量\n\n    #define UCHAR_MIN 0     // 因為無符號最小值就是0， limits.h 頭文件里沒有\n    #define UINT_MIN 0\n\n    int main(void)\n    {\n        printf(\"UCHAR_MAX = %hhu, UCHAR_MAX + 1 = %hhu\\n\", UCHAR_MAX, UCHAR_MAX + 1);\n        printf(\"UCHAR_MIN = %hhu, UCHAR_MIN - 1 = %hhu\\n\", UCHAR_MIN, UCHAR_MIN - 1);\n        printf(\"CHAR_MAX = %hhd, CHAR_MAX + 1 = %hhd\\n\", CHAR_MAX, CHAR_MAX + 1);\n        printf(\"CHAR_MIN = %hhd, CHAR_MIN - 1 = %hhd\\n\", CHAR_MIN, CHAR_MIN - 1);\n        putchar('\\n');\n\n        printf(\"UINT_MAX = %u, UINT_MAX + 1 = %u\\n\", UINT_MAX, UINT_MAX + 1);\n        printf(\"UINT_MIN = %u, UINT_MIN - 1 = %u\\n\", UINT_MIN, UINT_MIN - 1);\n        printf(\"INT_MAX = %d, INT_MAX + 1 = %d\\n\", INT_MAX, INT_MAX + 1);\n        printf(\"INT_MIN = %d, INT_MIN - 1 = %d\\n\", INT_MIN, INT_MAX - 1);\n\n        return 0;\n    }\n```\n輸出以下：\n![limit2](https://github.com/ByXc01/Blog-image/raw/master/binary/limit2.png \"ByXc\")\n好吧，終於警告了。\n我只把`char`類型的解釋一下， 其它的整數類型也一樣，就不作重複解釋了。以下是本人的瞎解釋，歡迎指出錯誤。\n\n**1.正溢出。 八位無符號最大值是255。**\n      1111 1111 [+255]\n\\+    0000 0001 [+1]\n= (1) 0000 0000 [0]\n符號位溢出。\n\n**2.負溢出。八位無符號。**\n     0000 0000 [0]\n\\-    0000 0001 [1]\n=    1111 1111 [+255]\n\n**3.正溢出。有符號八位最大值是127。**\n   0111 1111 [+127]\n\\+ 0000 0001 [+1]\n=  1000 0000 (補碼）[-128]\n符號位溢出\n\n**4.負溢出。有符號八位最小值是-128。補碼為: 1000 0000。**\n   1000 0000 （補碼)[-128]\n\\-  0000 0001 [+1]\n=  0111 1111 [+127]\n\n\npostscript:以上的代碼輸出可能不是所有的機器上都是一樣。因為本人剛看到了十五章，將現所學的進行解答。\n\n## 最後\n唉，不說了， 繼續研究二進制浮點數。\n","slug":"binary/binary","published":1,"updated":"2017-08-24T12:59:43.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts9610007t3lwzqcrbf3o","content":"<h1 id=\"原碼、反碼、補碼\"><a href=\"#原碼、反碼、補碼\" class=\"headerlink\" title=\"原碼、反碼、補碼\"></a>原碼、反碼、補碼</h1><p>此博客部分轉載 <a href=\"http://blog.csdn.net/hittata/article/details/9108323\" title=\"千年的塔\" target=\"_blank\" rel=\"external\">计算机为什么选用二进制补码（1）—原码、反码、补码</a></p>\n<h2 id=\"1-總的概念\"><a href=\"#1-總的概念\" class=\"headerlink\" title=\"1.總的概念\"></a>1.總的概念</h2><p>(1): 數在計算機中是以二進制形式表示的；<br>(2): 數分為有符號數和無符號數；<br>(3): 原碼、反碼、補碼都是有定點數的表示方法；<br>(4): 無符號數全部按正數處理；<br>(5): 一個有符號定點數的最高位，0是正，1是負；<br><a id=\"more\"></a></p>\n<h2 id=\"2-反碼，補碼定義\"><a href=\"#2-反碼，補碼定義\" class=\"headerlink\" title=\"2.反碼，補碼定義\"></a>2.反碼，補碼定義</h2><p><strong>正數：</strong><br>原碼 = 反碼 = 補碼</p>\n<p><strong>負數：</strong><br>原碼；<br>反碼 = 其原碼除符號位之外的各位求反；<br>補碼 = 反碼 + 1 （如果 + 1 之後又進位的， 要一直往前進位， 包括符號位；</p>\n<h2 id=\"3-運算示例\"><a href=\"#3-運算示例\" class=\"headerlink\" title=\"3.運算示例\"></a>3.運算示例</h2><p>(這裡按照一字節(byte)八位(Bit)表示)<br>正零： 0000 0000<br>負零： 1000 0000<br>其實這兩個數都是 0， 但它們的原碼卻有不同的表示。<br>但它們的補碼是一樣的， 都是 0000 0000。<br><strong>特別注意，如果 +1 之後有進位的， 要一直往前進位， 包括符號位!(這和反碼不同)</strong></p>\n<p>[1000 0000]補<br>= [1000 0000]反 + 1<br>= 1111 1111 + 1<br>= (1)0000 0000<br>= 0000 0000（最高位溢出了，符號位變成了0)</p>\n<h3 id=\"提一下補碼的兩個特性\"><a href=\"#提一下補碼的兩個特性\" class=\"headerlink\" title=\"提一下補碼的兩個特性\"></a>提一下補碼的兩個特性</h3><p><strong>(1): 負補碼轉原碼的方法是： 取補碼的反碼+1；</strong><br><strong>(2): 求補碼相反數的方法是： 反轉每一位(包括符號位，即0變1，1變0），然後加1。)；</strong><br>例1：<br>-1<br>（1000 0001）原碼<br>（1111 1110）反碼<br>（1111 1111）補碼<br>求（1111 1111）補碼表示的原碼。<br>（1111 1111）補碼<br>（1000 0000）反碼<br>（1000 0001）原碼</p>\n<p>例2：<br>由上面可知 -1 的補碼是 1111 1111，求 1111 1111 補碼的相反數。<br>（1111 1111）補碼<br>（0000 0000）取反<br>（0000 0001）+1</p>\n<h3 id=\"原碼和反碼的0都有兩種表示\"><a href=\"#原碼和反碼的0都有兩種表示\" class=\"headerlink\" title=\"原碼和反碼的0都有兩種表示\"></a>原碼和反碼的0都有兩種表示</h3><p>+0 = 0000 0001<br>-0 = 1000 0001<br>因此原碼和反碼表示的範圍都是是-127 ~ +127。<br><strong>但補碼的0只有一種表示，即 0000 0000。那麼補碼的表示範圍是-128 ~ +127</strong><br>當時本人一直是沒想明白：為什麼可以表示多一位，而且還是-128。<br>於是找到以下答案：<br>既然補碼表示0的是 0000 0000 那麼就多出一位，即: 1000 0000。其實這是一個規定， 這個補碼表示的是 -128。況且[1000 0000]也沒有相對應的原碼。</p>\n<h3 id=\"舉個栗子\"><a href=\"#舉個栗子\" class=\"headerlink\" title=\"舉個栗子\"></a>舉個栗子</h3><p>+100 0110(正數)<br>原碼: 0100 0110<br>反碼: 0100 0110<br>補碼: 0100 0110</p>\n<p>-100 0110(負數)<br>原碼： 1100 0110<br>反碼： 1011 1001<br>補碼： 1011 1010</p>\n<h2 id=\"4-幾個特殊定義：\"><a href=\"#4-幾個特殊定義：\" class=\"headerlink\" title=\"4.幾個特殊定義：\"></a>4.幾個特殊定義：</h2><p>(1): n位補碼能表示的範圍：有符號數是 -2^(n-1) 到 2^(n-1)-1。無符號是 0 到 2^(n-1)。<br>(2): -128 的補碼是 1000 0000, -128 + 1 = -127，(-127)補 = 1000 0001 = 1000 0000 + 0000 0001 符合運算規則。<br>(3): 0 的補碼 0000 0000</p>\n<h2 id=\"既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\"><a href=\"#既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\" class=\"headerlink\" title=\"既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\"></a>既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼</h2><p>其實也沒有學會，因為原碼、反碼和補碼都有公式。反正我是沒看明白。以前老師也沒講公式上來就是說：原碼符號位0表示正，1表示負。反碼就是除了符號位不變， 1變0,0變1。補碼就是反碼+1。</p>\n<h3 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h3><p>本人學C語言是看書入門的， c primer plus是一本很好的入門書。書中第六章的“6.2.1 終止 while 循環”有個問題就是一個變量自減特定次后會從負數變成正數，讓後終止循環。<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/while.png\" alt=\"c primer plus\" title=\"while\"><br>測試了一下， 果真如此。代碼如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// while.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> index = <span class=\"number\">1</span>;      <span class=\"comment\">// 使用 char ， 使用其它整數類型迭代次數較多。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (--index &lt; <span class=\"number\">5</span>)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, index);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\nlast value: %d\\n\"</span>, index);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出如下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/while2.png\" alt=\"program\" title=\"while test\"><br><strong>很明顯迭代的退出<code>index</code>的值是 127。 127 &lt; 5 表達式的值為0。<code>signed char</code>一字節（八位），從左往右第一位是符號位。負數用補碼存儲。範圍是 -2^(8-1) ~ 2^(8-1)-1， 即 -128 ~ 127。</strong><br>很好， 有點眉頭了。</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>下面我們來看一段代碼:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// limit.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> num = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"signed: %hhd, unsigned: %hhu\\n\"</span>, num, num);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出如下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/limit.png\" alt=\"limit\" title=\"ByXc\"><br>由例1已知， -1 的補碼是 1111 1111。如果是按有符號解析的話，第一位是符號位（為負），其餘是數值位。所以正是-1。但如果是無符號為的話，八位全是數值位，即是255。<br>還沒完咧， 繼續往下看：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// limit2.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;     // 提供明示常量</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UCHAR_MIN 0     <span class=\"comment\">// 因為無符號最小值就是0， limits.h 頭文件里沒有</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UINT_MIN 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UCHAR_MAX = %hhu, UCHAR_MAX + 1 = %hhu\\n\"</span>, UCHAR_MAX, UCHAR_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UCHAR_MIN = %hhu, UCHAR_MIN - 1 = %hhu\\n\"</span>, UCHAR_MIN, UCHAR_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"CHAR_MAX = %hhd, CHAR_MAX + 1 = %hhd\\n\"</span>, CHAR_MAX, CHAR_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"CHAR_MIN = %hhd, CHAR_MIN - 1 = %hhd\\n\"</span>, CHAR_MIN, CHAR_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UINT_MAX = %u, UINT_MAX + 1 = %u\\n\"</span>, UINT_MAX, UINT_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UINT_MIN = %u, UINT_MIN - 1 = %u\\n\"</span>, UINT_MIN, UINT_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"INT_MAX = %d, INT_MAX + 1 = %d\\n\"</span>, INT_MAX, INT_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"INT_MIN = %d, INT_MIN - 1 = %d\\n\"</span>, INT_MIN, INT_MAX - <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出以下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/limit2.png\" alt=\"limit2\" title=\"ByXc\"><br>好吧，終於警告了。<br>我只把<code>char</code>類型的解釋一下， 其它的整數類型也一樣，就不作重複解釋了。以下是本人的瞎解釋，歡迎指出錯誤。</p>\n<p><strong>1.正溢出。 八位無符號最大值是255。</strong><br>      1111 1111 [+255]<br>+    0000 0001 [+1]<br>= (1) 0000 0000 [0]<br>符號位溢出。</p>\n<p><strong>2.負溢出。八位無符號。</strong><br>     0000 0000 [0]<br>-    0000 0001 [1]<br>=    1111 1111 [+255]</p>\n<p><strong>3.正溢出。有符號八位最大值是127。</strong><br>   0111 1111 [+127]<br>+ 0000 0001 [+1]<br>=  1000 0000 (補碼）[-128]<br>符號位溢出</p>\n<p><strong>4.負溢出。有符號八位最小值是-128。補碼為: 1000 0000。</strong><br>   1000 0000 （補碼)[-128]<br>-  0000 0001 [+1]<br>=  0111 1111 [+127]</p>\n<p>postscript:以上的代碼輸出可能不是所有的機器上都是一樣。因為本人剛看到了十五章，將現所學的進行解答。</p>\n<h2 id=\"最後\"><a href=\"#最後\" class=\"headerlink\" title=\"最後\"></a>最後</h2><p>唉，不說了， 繼續研究二進制浮點數。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"原碼、反碼、補碼\"><a href=\"#原碼、反碼、補碼\" class=\"headerlink\" title=\"原碼、反碼、補碼\"></a>原碼、反碼、補碼</h1><p>此博客部分轉載 <a href=\"http://blog.csdn.net/hittata/article/details/9108323\" title=\"千年的塔\" target=\"_blank\" rel=\"external\">计算机为什么选用二进制补码（1）—原码、反码、补码</a></p>\n<h2 id=\"1-總的概念\"><a href=\"#1-總的概念\" class=\"headerlink\" title=\"1.總的概念\"></a>1.總的概念</h2><p>(1): 數在計算機中是以二進制形式表示的；<br>(2): 數分為有符號數和無符號數；<br>(3): 原碼、反碼、補碼都是有定點數的表示方法；<br>(4): 無符號數全部按正數處理；<br>(5): 一個有符號定點數的最高位，0是正，1是負；<br></p>","more":"<p></p>\n<h2 id=\"2-反碼，補碼定義\"><a href=\"#2-反碼，補碼定義\" class=\"headerlink\" title=\"2.反碼，補碼定義\"></a>2.反碼，補碼定義</h2><p><strong>正數：</strong><br>原碼 = 反碼 = 補碼</p>\n<p><strong>負數：</strong><br>原碼；<br>反碼 = 其原碼除符號位之外的各位求反；<br>補碼 = 反碼 + 1 （如果 + 1 之後又進位的， 要一直往前進位， 包括符號位；</p>\n<h2 id=\"3-運算示例\"><a href=\"#3-運算示例\" class=\"headerlink\" title=\"3.運算示例\"></a>3.運算示例</h2><p>(這裡按照一字節(byte)八位(Bit)表示)<br>正零： 0000 0000<br>負零： 1000 0000<br>其實這兩個數都是 0， 但它們的原碼卻有不同的表示。<br>但它們的補碼是一樣的， 都是 0000 0000。<br><strong>特別注意，如果 +1 之後有進位的， 要一直往前進位， 包括符號位!(這和反碼不同)</strong></p>\n<p>[1000 0000]補<br>= [1000 0000]反 + 1<br>= 1111 1111 + 1<br>= (1)0000 0000<br>= 0000 0000（最高位溢出了，符號位變成了0)</p>\n<h3 id=\"提一下補碼的兩個特性\"><a href=\"#提一下補碼的兩個特性\" class=\"headerlink\" title=\"提一下補碼的兩個特性\"></a>提一下補碼的兩個特性</h3><p><strong>(1): 負補碼轉原碼的方法是： 取補碼的反碼+1；</strong><br><strong>(2): 求補碼相反數的方法是： 反轉每一位(包括符號位，即0變1，1變0），然後加1。)；</strong><br>例1：<br>-1<br>（1000 0001）原碼<br>（1111 1110）反碼<br>（1111 1111）補碼<br>求（1111 1111）補碼表示的原碼。<br>（1111 1111）補碼<br>（1000 0000）反碼<br>（1000 0001）原碼</p>\n<p>例2：<br>由上面可知 -1 的補碼是 1111 1111，求 1111 1111 補碼的相反數。<br>（1111 1111）補碼<br>（0000 0000）取反<br>（0000 0001）+1</p>\n<h3 id=\"原碼和反碼的0都有兩種表示\"><a href=\"#原碼和反碼的0都有兩種表示\" class=\"headerlink\" title=\"原碼和反碼的0都有兩種表示\"></a>原碼和反碼的0都有兩種表示</h3><p>+0 = 0000 0001<br>-0 = 1000 0001<br>因此原碼和反碼表示的範圍都是是-127 ~ +127。<br><strong>但補碼的0只有一種表示，即 0000 0000。那麼補碼的表示範圍是-128 ~ +127</strong><br>當時本人一直是沒想明白：為什麼可以表示多一位，而且還是-128。<br>於是找到以下答案：<br>既然補碼表示0的是 0000 0000 那麼就多出一位，即: 1000 0000。其實這是一個規定， 這個補碼表示的是 -128。況且[1000 0000]也沒有相對應的原碼。</p>\n<h3 id=\"舉個栗子\"><a href=\"#舉個栗子\" class=\"headerlink\" title=\"舉個栗子\"></a>舉個栗子</h3><p>+100 0110(正數)<br>原碼: 0100 0110<br>反碼: 0100 0110<br>補碼: 0100 0110</p>\n<p>-100 0110(負數)<br>原碼： 1100 0110<br>反碼： 1011 1001<br>補碼： 1011 1010</p>\n<h2 id=\"4-幾個特殊定義：\"><a href=\"#4-幾個特殊定義：\" class=\"headerlink\" title=\"4.幾個特殊定義：\"></a>4.幾個特殊定義：</h2><p>(1): n位補碼能表示的範圍：有符號數是 -2^(n-1) 到 2^(n-1)-1。無符號是 0 到 2^(n-1)。<br>(2): -128 的補碼是 1000 0000, -128 + 1 = -127，(-127)補 = 1000 0001 = 1000 0000 + 0000 0001 符合運算規則。<br>(3): 0 的補碼 0000 0000</p>\n<h2 id=\"既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\"><a href=\"#既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\" class=\"headerlink\" title=\"既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼\"></a>既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼</h2><p>其實也沒有學會，因為原碼、反碼和補碼都有公式。反正我是沒看明白。以前老師也沒講公式上來就是說：原碼符號位0表示正，1表示負。反碼就是除了符號位不變， 1變0,0變1。補碼就是反碼+1。</p>\n<h3 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h3><p>本人學C語言是看書入門的， c primer plus是一本很好的入門書。書中第六章的“6.2.1 終止 while 循環”有個問題就是一個變量自減特定次后會從負數變成正數，讓後終止循環。<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/while.png\" alt=\"c primer plus\" title=\"while\"><br>測試了一下， 果真如此。代碼如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// while.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> index = <span class=\"number\">1</span>;      <span class=\"comment\">// 使用 char ， 使用其它整數類型迭代次數較多。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (--index &lt; <span class=\"number\">5</span>)</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, index);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\\nlast value: %d\\n\"</span>, index);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出如下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/while2.png\" alt=\"program\" title=\"while test\"><br><strong>很明顯迭代的退出<code>index</code>的值是 127。 127 &lt; 5 表達式的值為0。<code>signed char</code>一字節（八位），從左往右第一位是符號位。負數用補碼存儲。範圍是 -2^(8-1) ~ 2^(8-1)-1， 即 -128 ~ 127。</strong><br>很好， 有點眉頭了。</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>下面我們來看一段代碼:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// limit.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> num = <span class=\"number\">-1</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"signed: %hhd, unsigned: %hhu\\n\"</span>, num, num);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出如下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/limit.png\" alt=\"limit\" title=\"ByXc\"><br>由例1已知， -1 的補碼是 1111 1111。如果是按有符號解析的話，第一位是符號位（為負），其餘是數值位。所以正是-1。但如果是無符號為的話，八位全是數值位，即是255。<br>還沒完咧， 繼續往下看：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// limit2.c</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;     // 提供明示常量</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UCHAR_MIN 0     <span class=\"comment\">// 因為無符號最小值就是0， limits.h 頭文件里沒有</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UINT_MIN 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UCHAR_MAX = %hhu, UCHAR_MAX + 1 = %hhu\\n\"</span>, UCHAR_MAX, UCHAR_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UCHAR_MIN = %hhu, UCHAR_MIN - 1 = %hhu\\n\"</span>, UCHAR_MIN, UCHAR_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"CHAR_MAX = %hhd, CHAR_MAX + 1 = %hhd\\n\"</span>, CHAR_MAX, CHAR_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"CHAR_MIN = %hhd, CHAR_MIN - 1 = %hhd\\n\"</span>, CHAR_MIN, CHAR_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UINT_MAX = %u, UINT_MAX + 1 = %u\\n\"</span>, UINT_MAX, UINT_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"UINT_MIN = %u, UINT_MIN - 1 = %u\\n\"</span>, UINT_MIN, UINT_MIN - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"INT_MAX = %d, INT_MAX + 1 = %d\\n\"</span>, INT_MAX, INT_MAX + <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"INT_MIN = %d, INT_MIN - 1 = %d\\n\"</span>, INT_MIN, INT_MAX - <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>輸出以下：<br><img src=\"https://github.com/ByXc01/Blog-image/raw/master/binary/limit2.png\" alt=\"limit2\" title=\"ByXc\"><br>好吧，終於警告了。<br>我只把<code>char</code>類型的解釋一下， 其它的整數類型也一樣，就不作重複解釋了。以下是本人的瞎解釋，歡迎指出錯誤。</p>\n<p><strong>1.正溢出。 八位無符號最大值是255。</strong><br>      1111 1111 [+255]<br>+    0000 0001 [+1]<br>= (1) 0000 0000 [0]<br>符號位溢出。</p>\n<p><strong>2.負溢出。八位無符號。</strong><br>     0000 0000 [0]<br>-    0000 0001 [1]<br>=    1111 1111 [+255]</p>\n<p><strong>3.正溢出。有符號八位最大值是127。</strong><br>   0111 1111 [+127]<br>+ 0000 0001 [+1]<br>=  1000 0000 (補碼）[-128]<br>符號位溢出</p>\n<p><strong>4.負溢出。有符號八位最小值是-128。補碼為: 1000 0000。</strong><br>   1000 0000 （補碼)[-128]<br>-  0000 0001 [+1]<br>=  0111 1111 [+127]</p>\n<p>postscript:以上的代碼輸出可能不是所有的機器上都是一樣。因為本人剛看到了十五章，將現所學的進行解答。</p>\n<h2 id=\"最後\"><a href=\"#最後\" class=\"headerlink\" title=\"最後\"></a>最後</h2><p>唉，不說了， 繼續研究二進制浮點數。</p>"},{"title":"關於尾遞歸的問題","date":"2017-05-26T12:43:33.000Z","_content":"\n### （我們今天來談談尾遞歸的問題）\n\n***\n\n### c primer plus 定義\n\n**尾遞歸**， 這是本人學到遞歸的一個疑惑點。 在 《*c primer plus* 》中文第六版中，\n\n尾遞歸的是這樣定義的：\n\n**“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在`return`語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”**\n\n<!--more-->\n---\n\n接著書上給的尾遞歸例子是這樣的:\n\n\n``` c\n    long rfact(int n)\n    {\n        long ans;\n\n        if (n > 0)\n            ans = n * rfact(n - 1);\n        else\n            ans = 1;\n\n        return ans;\n    }\n\n```\n這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《*c primer plus*》的定義，也是算尾遞歸吧)：\n``` c\n\tlong rfact(int n)\n\t{\n        if (n <= 1)\n            return 1;\n\n        return rfact(n - 1) * n;\t\t// 省略不必要的存儲\n\t}\n```\n* * *\n\n別以為就這樣就完事了， 那時候我對**尾遞歸**還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。\n\n但是在百度百科是這樣定義的：\n\n### 百度百科定義\n\n**“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”**\n\n(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：\n``` c\n    int facttail(int n, int a)\n    {\n        /* Compute a factorialina tail - recursive manner */\n        if (n < 0)\n            return 0;\n        else if (n == 0)\n            return 1;\n        else if (n == 1)\n            return a;\n        else\n            return facttail(n - 1, n * a);\n    }\n```\n**“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”**\n\n沒錯，照百度百科的定義這個代碼才是**尾遞歸**， 算法也比前兩個例子簡便要好許多。\n\n- - -\n\n### 博客園 twoon 的博客截取\n\n在博客園看到一個不錯的博文[說說尾遞歸](http://www.cnblogs.com/catch/p/3495450.html \"說說尾遞歸\")\n\n博文中的**尾遞歸**的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。\n\n### 什麼是尾遞歸\n\n什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。\n``` c\n\t// 先不考慮溢出的問題\n\tint func(int n)\n\t{\n        if (n <= 1)\n            return 1;\n\n        return (n * func(n - 1));\n\t}\n```\n原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:\n\n*  1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。\n\n*  2: 執行函數。\n\n*  3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 **gdb** 和一點 **彙編** 再作深入研究)\n\n因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C ... 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。\n\n**而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:**\n``` c\n    // 先不考慮溢出\n    int tail_func(int n, int res)\n    {\n        if (n <= 1)\n            return res;\n\n        return tail_func(n - 1, n * res);\n    }\n```\n``` c\n    // 向下面這樣調用\n    tail_func(10000000000, 1);\n```\n從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n \\* res) 的返回值，才能計算它自己的返回結果 -- 它就完全等於 tail_fun(n - 1, n \\* res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。\n\n這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！\n\n### 尾遞歸的調用棧優化特性\n\n相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：\n``` c\n\t#include <stdio.h>\n\n\tint tail_func(int n, int res)\n\t{\n        if (n <= 1)\n            return res;\n\n        return tail_func(n - 1, n * res);\n\t}\n\n\tint main(void)\n\t{\n        int dummy[1014 * 1024];\t\t// 盡可能佔用棧\n\n        tail_func(2048 * 2048, 1);\n\n        return 0;\n\t}\n```\n上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 `gcc -Wall factorial_tail.c `編譯讓後運行的話，程序會包棧崩潰。\n\n沒開編譯優化：\n\n![沒開編譯優化](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_o2.png \"沒開編譯優化\")\n\n但如果開優化的話： `gcc -Wall -O2 factorial_tail.c`， 上面的程序最後就能正常運行。\n\n開了`-O2` 編譯優化:\n\n![開了 -O2 編譯優化](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/02.png \"開了 -O2 編譯優化\")\n\n**這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。**\n\n我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 \n\n![沒開優化彙編](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_no2s.png \"沒開優化彙編\")\n\n**注意上面 `tail_func` 函數中的 `call` 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 `jmp` 去 `tail_func`， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。**\n\n我們在看看開了優化得到的彙編:\n\n![開了優化彙編](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/o2eds.png \"開了優化彙編\")\n\n注意 `tail_func` 函數彙編中 `imull %ecx, %eax` 和 `jne .L3`。`tail_func()` 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!\n\n這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。\n\n## 結束語\n\n好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。\n\n還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。\n\n**最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)**\n\n#  Happy Birthday to myself.\n","source":"_posts/tail-recursion/tail_recursion.md","raw":"---\ntitle: 關於尾遞歸的問題\ndate: 2017-05-26 20:43:33\ntags: 尾遞歸\n---\n\n### （我們今天來談談尾遞歸的問題）\n\n***\n\n### c primer plus 定義\n\n**尾遞歸**， 這是本人學到遞歸的一個疑惑點。 在 《*c primer plus* 》中文第六版中，\n\n尾遞歸的是這樣定義的：\n\n**“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在`return`語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”**\n\n<!--more-->\n---\n\n接著書上給的尾遞歸例子是這樣的:\n\n\n``` c\n    long rfact(int n)\n    {\n        long ans;\n\n        if (n > 0)\n            ans = n * rfact(n - 1);\n        else\n            ans = 1;\n\n        return ans;\n    }\n\n```\n這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《*c primer plus*》的定義，也是算尾遞歸吧)：\n``` c\n\tlong rfact(int n)\n\t{\n        if (n <= 1)\n            return 1;\n\n        return rfact(n - 1) * n;\t\t// 省略不必要的存儲\n\t}\n```\n* * *\n\n別以為就這樣就完事了， 那時候我對**尾遞歸**還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。\n\n但是在百度百科是這樣定義的：\n\n### 百度百科定義\n\n**“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”**\n\n(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：\n``` c\n    int facttail(int n, int a)\n    {\n        /* Compute a factorialina tail - recursive manner */\n        if (n < 0)\n            return 0;\n        else if (n == 0)\n            return 1;\n        else if (n == 1)\n            return a;\n        else\n            return facttail(n - 1, n * a);\n    }\n```\n**“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”**\n\n沒錯，照百度百科的定義這個代碼才是**尾遞歸**， 算法也比前兩個例子簡便要好許多。\n\n- - -\n\n### 博客園 twoon 的博客截取\n\n在博客園看到一個不錯的博文[說說尾遞歸](http://www.cnblogs.com/catch/p/3495450.html \"說說尾遞歸\")\n\n博文中的**尾遞歸**的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。\n\n### 什麼是尾遞歸\n\n什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。\n``` c\n\t// 先不考慮溢出的問題\n\tint func(int n)\n\t{\n        if (n <= 1)\n            return 1;\n\n        return (n * func(n - 1));\n\t}\n```\n原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:\n\n*  1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。\n\n*  2: 執行函數。\n\n*  3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 **gdb** 和一點 **彙編** 再作深入研究)\n\n因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C ... 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。\n\n**而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:**\n``` c\n    // 先不考慮溢出\n    int tail_func(int n, int res)\n    {\n        if (n <= 1)\n            return res;\n\n        return tail_func(n - 1, n * res);\n    }\n```\n``` c\n    // 向下面這樣調用\n    tail_func(10000000000, 1);\n```\n從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n \\* res) 的返回值，才能計算它自己的返回結果 -- 它就完全等於 tail_fun(n - 1, n \\* res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。\n\n這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！\n\n### 尾遞歸的調用棧優化特性\n\n相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：\n``` c\n\t#include <stdio.h>\n\n\tint tail_func(int n, int res)\n\t{\n        if (n <= 1)\n            return res;\n\n        return tail_func(n - 1, n * res);\n\t}\n\n\tint main(void)\n\t{\n        int dummy[1014 * 1024];\t\t// 盡可能佔用棧\n\n        tail_func(2048 * 2048, 1);\n\n        return 0;\n\t}\n```\n上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 `gcc -Wall factorial_tail.c `編譯讓後運行的話，程序會包棧崩潰。\n\n沒開編譯優化：\n\n![沒開編譯優化](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_o2.png \"沒開編譯優化\")\n\n但如果開優化的話： `gcc -Wall -O2 factorial_tail.c`， 上面的程序最後就能正常運行。\n\n開了`-O2` 編譯優化:\n\n![開了 -O2 編譯優化](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/02.png \"開了 -O2 編譯優化\")\n\n**這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。**\n\n我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 \n\n![沒開優化彙編](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_no2s.png \"沒開優化彙編\")\n\n**注意上面 `tail_func` 函數中的 `call` 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 `jmp` 去 `tail_func`， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。**\n\n我們在看看開了優化得到的彙編:\n\n![開了優化彙編](https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/o2eds.png \"開了優化彙編\")\n\n注意 `tail_func` 函數彙編中 `imull %ecx, %eax` 和 `jne .L3`。`tail_func()` 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!\n\n這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。\n\n## 結束語\n\n好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。\n\n還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。\n\n**最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)**\n\n#  Happy Birthday to myself.\n","slug":"tail-recursion/tail_recursion","published":1,"updated":"2017-08-24T12:00:30.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts96q0008t3lw6vdfbgr5","content":"<h3 id=\"（我們今天來談談尾遞歸的問題）\"><a href=\"#（我們今天來談談尾遞歸的問題）\" class=\"headerlink\" title=\"（我們今天來談談尾遞歸的問題）\"></a>（我們今天來談談尾遞歸的問題）</h3><hr>\n<h3 id=\"c-primer-plus-定義\"><a href=\"#c-primer-plus-定義\" class=\"headerlink\" title=\"c primer plus 定義\"></a>c primer plus 定義</h3><p><strong>尾遞歸</strong>， 這是本人學到遞歸的一個疑惑點。 在 《<em>c primer plus</em> 》中文第六版中，</p>\n<p>尾遞歸的是這樣定義的：</p>\n<p><strong>“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在<code>return</code>語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”</strong></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>接著書上給的尾遞歸例子是這樣的:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> ans;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        ans = n * rfact(n - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        ans = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《<em>c primer plus</em>》的定義，也是算尾遞歸吧)：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> rfact(n - <span class=\"number\">1</span>) * n;\t\t<span class=\"comment\">// 省略不必要的存儲</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>別以為就這樣就完事了， 那時候我對<strong>尾遞歸</strong>還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。</p>\n<p>但是在百度百科是這樣定義的：</p>\n<h3 id=\"百度百科定義\"><a href=\"#百度百科定義\" class=\"headerlink\" title=\"百度百科定義\"></a>百度百科定義</h3><p><strong>“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”</strong></p>\n<p>(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">facttail</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> a)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">/* Compute a factorialina tail - recursive manner */</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> a;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> facttail(n - <span class=\"number\">1</span>, n * a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”</strong></p>\n<p>沒錯，照百度百科的定義這個代碼才是<strong>尾遞歸</strong>， 算法也比前兩個例子簡便要好許多。</p>\n<hr>\n<h3 id=\"博客園-twoon-的博客截取\"><a href=\"#博客園-twoon-的博客截取\" class=\"headerlink\" title=\"博客園 twoon 的博客截取\"></a>博客園 twoon 的博客截取</h3><p>在博客園看到一個不錯的博文<a href=\"http://www.cnblogs.com/catch/p/3495450.html\" title=\"說說尾遞歸\" target=\"_blank\" rel=\"external\">說說尾遞歸</a></p>\n<p>博文中的<strong>尾遞歸</strong>的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。</p>\n<h3 id=\"什麼是尾遞歸\"><a href=\"#什麼是尾遞歸\" class=\"headerlink\" title=\"什麼是尾遞歸\"></a>什麼是尾遞歸</h3><p>什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出的問題</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> (n * func(n - <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:</p>\n<ul>\n<li><p>1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。</p>\n</li>\n<li><p>2: 執行函數。</p>\n</li>\n<li><p>3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 <strong>gdb</strong> 和一點 <strong>彙編</strong> 再作深入研究)</p>\n</li>\n</ul>\n<p>因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C … 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。</p>\n<p><strong>而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 向下面這樣調用</span></div><div class=\"line\">tail_func(<span class=\"number\">10000000000</span>, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<p>從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n * res) 的返回值，才能計算它自己的返回結果 – 它就完全等於 tail_fun(n - 1, n * res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。</p>\n<p>這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！</p>\n<h3 id=\"尾遞歸的調用棧優化特性\"><a href=\"#尾遞歸的調用棧優化特性\" class=\"headerlink\" title=\"尾遞歸的調用棧優化特性\"></a>尾遞歸的調用棧優化特性</h3><p>相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> dummy[<span class=\"number\">1014</span> * <span class=\"number\">1024</span>];\t\t<span class=\"comment\">// 盡可能佔用棧</span></div><div class=\"line\"></div><div class=\"line\">       tail_func(<span class=\"number\">2048</span> * <span class=\"number\">2048</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 <code>gcc -Wall factorial_tail.c</code>編譯讓後運行的話，程序會包棧崩潰。</p>\n<p>沒開編譯優化：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_o2.png\" alt=\"沒開編譯優化\" title=\"沒開編譯優化\"></p>\n<p>但如果開優化的話： <code>gcc -Wall -O2 factorial_tail.c</code>， 上面的程序最後就能正常運行。</p>\n<p>開了<code>-O2</code> 編譯優化:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/02.png\" alt=\"開了 -O2 編譯優化\" title=\"開了 -O2 編譯優化\"></p>\n<p><strong>這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。</strong></p>\n<p>我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 </p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_no2s.png\" alt=\"沒開優化彙編\" title=\"沒開優化彙編\"></p>\n<p><strong>注意上面 <code>tail_func</code> 函數中的 <code>call</code> 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 <code>jmp</code> 去 <code>tail_func</code>， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。</strong></p>\n<p>我們在看看開了優化得到的彙編:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/o2eds.png\" alt=\"開了優化彙編\" title=\"開了優化彙編\"></p>\n<p>注意 <code>tail_func</code> 函數彙編中 <code>imull %ecx, %eax</code> 和 <code>jne .L3</code>。<code>tail_func()</code> 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!</p>\n<p>這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。</p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。</p>\n<p>還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。</p>\n<p><strong>最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)</strong></p>\n<h1 id=\"Happy-Birthday-to-myself\"><a href=\"#Happy-Birthday-to-myself\" class=\"headerlink\" title=\"Happy Birthday to myself.\"></a>Happy Birthday to myself.</h1>","site":{"data":{}},"excerpt":"<h3 id=\"（我們今天來談談尾遞歸的問題）\"><a href=\"#（我們今天來談談尾遞歸的問題）\" class=\"headerlink\" title=\"（我們今天來談談尾遞歸的問題）\"></a>（我們今天來談談尾遞歸的問題）</h3><hr>\n<h3 id=\"c-primer-plus-定義\"><a href=\"#c-primer-plus-定義\" class=\"headerlink\" title=\"c primer plus 定義\"></a>c primer plus 定義</h3><p><strong>尾遞歸</strong>， 這是本人學到遞歸的一個疑惑點。 在 《<em>c primer plus</em> 》中文第六版中，</p>\n<p>尾遞歸的是這樣定義的：</p>\n<p><strong>“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在<code>return</code>語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”</strong></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","more":"<p>接著書上給的尾遞歸例子是這樣的:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> ans;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        ans = n * rfact(n - <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        ans = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《<em>c primer plus</em>》的定義，也是算尾遞歸吧)：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> rfact(n - <span class=\"number\">1</span>) * n;\t\t<span class=\"comment\">// 省略不必要的存儲</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>別以為就這樣就完事了， 那時候我對<strong>尾遞歸</strong>還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。</p>\n<p>但是在百度百科是這樣定義的：</p>\n<h3 id=\"百度百科定義\"><a href=\"#百度百科定義\" class=\"headerlink\" title=\"百度百科定義\"></a>百度百科定義</h3><p><strong>“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”</strong></p>\n<p>(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">facttail</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> a)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">/* Compute a factorialina tail - recursive manner */</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> a;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> facttail(n - <span class=\"number\">1</span>, n * a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”</strong></p>\n<p>沒錯，照百度百科的定義這個代碼才是<strong>尾遞歸</strong>， 算法也比前兩個例子簡便要好許多。</p>\n<hr>\n<h3 id=\"博客園-twoon-的博客截取\"><a href=\"#博客園-twoon-的博客截取\" class=\"headerlink\" title=\"博客園 twoon 的博客截取\"></a>博客園 twoon 的博客截取</h3><p>在博客園看到一個不錯的博文<a href=\"http://www.cnblogs.com/catch/p/3495450.html\" title=\"說說尾遞歸\" target=\"_blank\" rel=\"external\">說說尾遞歸</a></p>\n<p>博文中的<strong>尾遞歸</strong>的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。</p>\n<h3 id=\"什麼是尾遞歸\"><a href=\"#什麼是尾遞歸\" class=\"headerlink\" title=\"什麼是尾遞歸\"></a>什麼是尾遞歸</h3><p>什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出的問題</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> (n * func(n - <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:</p>\n<ul>\n<li><p>1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。</p>\n</li>\n<li><p>2: 執行函數。</p>\n</li>\n<li><p>3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 <strong>gdb</strong> 和一點 <strong>彙編</strong> 再作深入研究)</p>\n</li>\n</ul>\n<p>因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C … 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。</p>\n<p><strong>而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先不考慮溢出</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 向下面這樣調用</span></div><div class=\"line\">tail_func(<span class=\"number\">10000000000</span>, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<p>從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n * res) 的返回值，才能計算它自己的返回結果 – 它就完全等於 tail_fun(n - 1, n * res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。</p>\n<p>這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！</p>\n<h3 id=\"尾遞歸的調用棧優化特性\"><a href=\"#尾遞歸的調用棧優化特性\" class=\"headerlink\" title=\"尾遞歸的調用棧優化特性\"></a>尾遞歸的調用棧優化特性</h3><p>相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tail_func</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> res)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> res;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> tail_func(n - <span class=\"number\">1</span>, n * res);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> dummy[<span class=\"number\">1014</span> * <span class=\"number\">1024</span>];\t\t<span class=\"comment\">// 盡可能佔用棧</span></div><div class=\"line\"></div><div class=\"line\">       tail_func(<span class=\"number\">2048</span> * <span class=\"number\">2048</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 <code>gcc -Wall factorial_tail.c</code>編譯讓後運行的話，程序會包棧崩潰。</p>\n<p>沒開編譯優化：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_o2.png\" alt=\"沒開編譯優化\" title=\"沒開編譯優化\"></p>\n<p>但如果開優化的話： <code>gcc -Wall -O2 factorial_tail.c</code>， 上面的程序最後就能正常運行。</p>\n<p>開了<code>-O2</code> 編譯優化:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/02.png\" alt=\"開了 -O2 編譯優化\" title=\"開了 -O2 編譯優化\"></p>\n<p><strong>這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。</strong></p>\n<p>我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 </p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/not_no2s.png\" alt=\"沒開優化彙編\" title=\"沒開優化彙編\"></p>\n<p><strong>注意上面 <code>tail_func</code> 函數中的 <code>call</code> 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 <code>jmp</code> 去 <code>tail_func</code>， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。</strong></p>\n<p>我們在看看開了優化得到的彙編:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/tail_recusion/o2eds.png\" alt=\"開了優化彙編\" title=\"開了優化彙編\"></p>\n<p>注意 <code>tail_func</code> 函數彙編中 <code>imull %ecx, %eax</code> 和 <code>jne .L3</code>。<code>tail_func()</code> 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!</p>\n<p>這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。</p>\n<h2 id=\"結束語\"><a href=\"#結束語\" class=\"headerlink\" title=\"結束語\"></a>結束語</h2><p>好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。</p>\n<p>還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。</p>\n<p><strong>最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)</strong></p>\n<h1 id=\"Happy-Birthday-to-myself\"><a href=\"#Happy-Birthday-to-myself\" class=\"headerlink\" title=\"Happy Birthday to myself.\"></a>Happy Birthday to myself.</h1>"},{"title":"bug","date":"2017-05-26T17:33:41.000Z","_content":"\n在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。\n但预览功能还是挺好的\n","source":"_posts/bug/bug.md","raw":"---\ntitle: bug\ndate: 2017-05-27 01:33:41\ntags: 隨筆\n---\n\n在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。\n但预览功能还是挺好的\n","slug":"bug/bug","published":1,"updated":"2017-08-24T13:29:21.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts96z000bt3lwc68tz0st","content":"<p>在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。<br>但预览功能还是挺好的</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 windows 用 markdownpad 写完后， 经测试有些功能不兼容 Linux 的 ubuntu 。<br>但预览功能还是挺好的</p>\n"},{"title":"C11 gets_s() 函數","date":"2017-05-29T10:20:27.000Z","_content":"\n### C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\n\nC11 K.3.5.7.1 The gets_s function 代碼如下:\n\n```c\n\t#define __STDC_WANT_LIB_EXT1__ 1\n\t#include <stdio.h>\n\tchar * gets_s(char *s, rsize_t n);\n```\n<!--more-->\n\n### 因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\n\n在 《*c primer plus*》 也沒過多的介紹。\n\n![gets_s() 介紹](https://github.com/ByXc01/Blog-image/raw/master/gets_s/gets_s.png \"gets_s()介紹\")\n\n詳細可查看[C 語言參考手冊](http://zh.cppreference.com/w/c/io/gets \"C 語言查考手冊\")\n","source":"_posts/gets-s/gets_s.md","raw":"---\ntitle: C11 gets_s() 函數\ndate: 2017-05-29 18:20:27\ntags: gets_s\n---\n\n### C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\n\nC11 K.3.5.7.1 The gets_s function 代碼如下:\n\n```c\n\t#define __STDC_WANT_LIB_EXT1__ 1\n\t#include <stdio.h>\n\tchar * gets_s(char *s, rsize_t n);\n```\n<!--more-->\n\n### 因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\n\n在 《*c primer plus*》 也沒過多的介紹。\n\n![gets_s() 介紹](https://github.com/ByXc01/Blog-image/raw/master/gets_s/gets_s.png \"gets_s()介紹\")\n\n詳細可查看[C 語言參考手冊](http://zh.cppreference.com/w/c/io/gets \"C 語言查考手冊\")\n","slug":"gets-s/gets_s","published":1,"updated":"2017-08-24T12:28:52.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts979000ct3lw964x3xs6","content":"<h3 id=\"C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\"><a href=\"#C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\" class=\"headerlink\" title=\"C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\"></a>C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。</h3><p>C11 K.3.5.7.1 The gets_s function 代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __STDC_WANT_LIB_EXT1__ 1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">gets_s</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">rsize_t</span> n)</span></span>;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\"><a href=\"#因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\" class=\"headerlink\" title=\"因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\"></a>因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。</h3><p>在 《<em>c primer plus</em>》 也沒過多的介紹。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/gets_s/gets_s.png\" alt=\"gets_s() 介紹\" title=\"gets_s()介紹\"></p>\n<p>詳細可查看<a href=\"http://zh.cppreference.com/w/c/io/gets\" title=\"C 語言查考手冊\" target=\"_blank\" rel=\"external\">C 語言參考手冊</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\"><a href=\"#C11-標準-IS0-IEC-9899-201x-中，-gets-函數被刪除，-引進了新的函數-gets-s-。\" class=\"headerlink\" title=\"C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。\"></a>C11 標準 (IS0/IEC 9899.201x) 中， gets() 函數被刪除， 引進了新的函數 gets_s() 。</h3><p>C11 K.3.5.7.1 The gets_s function 代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __STDC_WANT_LIB_EXT1__ 1</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">gets_s</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">rsize_t</span> n)</span></span>;</div></pre></td></tr></table></figure>","more":"<h3 id=\"因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\"><a href=\"#因為目前-GCC-中還沒有完全實現該標準，-因此-gets-s-函數尚未包含在目前的-GNU-工具鏈中。-Clang-也暫時沒有增加對-gets-s-的支持。\" class=\"headerlink\" title=\"因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。\"></a>因為目前 GCC 中還沒有完全實現該標準， 因此 gets_s() 函數尚未包含在目前的 GNU 工具鏈中。 Clang 也暫時沒有增加對 gets_s() 的支持。</h3><p>在 《<em>c primer plus</em>》 也沒過多的介紹。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/gets_s/gets_s.png\" alt=\"gets_s() 介紹\" title=\"gets_s()介紹\"></p>\n<p>詳細可查看<a href=\"http://zh.cppreference.com/w/c/io/gets\" title=\"C 語言查考手冊\" target=\"_blank\" rel=\"external\">C 語言參考手冊</a></p>"},{"title":"programme exercise","date":"2017-05-26T13:22:05.000Z","_content":"\n# c primer plus 6 programme exercise\n\n本人在 c primer plus 中文第六版的[編程練習題](https://github.com/ByXc01/cpp6-programme-exercise \"編程練習題\")做的答案(不定期更新)。\n如有需要的的朋友可自行clone。 部分源碼參考標準答案。\n(可能本人做的不太好，望見諒。有錯請指出。有更好題的可以fork合並)\n這已經算我在github 的一個大項目了，dalao 自行忽略。\n\n<!--more-->\n\n![編程練習](https://github.com/ByXc01/Blog-image/raw/master/programme_exercise/github_pe.png \"編程練習\")\n","source":"_posts/programme-exercise/programme_exercise.md","raw":"---\ntitle: programme exercise\ndate: 2017-05-26 21:22:05\ntags: github\n---\n\n# c primer plus 6 programme exercise\n\n本人在 c primer plus 中文第六版的[編程練習題](https://github.com/ByXc01/cpp6-programme-exercise \"編程練習題\")做的答案(不定期更新)。\n如有需要的的朋友可自行clone。 部分源碼參考標準答案。\n(可能本人做的不太好，望見諒。有錯請指出。有更好題的可以fork合並)\n這已經算我在github 的一個大項目了，dalao 自行忽略。\n\n<!--more-->\n\n![編程練習](https://github.com/ByXc01/Blog-image/raw/master/programme_exercise/github_pe.png \"編程練習\")\n","slug":"programme-exercise/programme_exercise","published":1,"updated":"2017-08-24T12:06:17.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts97i000ft3lwgg33ehtp","content":"<h1 id=\"c-primer-plus-6-programme-exercise\"><a href=\"#c-primer-plus-6-programme-exercise\" class=\"headerlink\" title=\"c primer plus 6 programme exercise\"></a>c primer plus 6 programme exercise</h1><p>本人在 c primer plus 中文第六版的<a href=\"https://github.com/ByXc01/cpp6-programme-exercise\" title=\"編程練習題\" target=\"_blank\" rel=\"external\">編程練習題</a>做的答案(不定期更新)。<br>如有需要的的朋友可自行clone。 部分源碼參考標準答案。<br>(可能本人做的不太好，望見諒。有錯請指出。有更好題的可以fork合並)<br>這已經算我在github 的一個大項目了，dalao 自行忽略。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/programme_exercise/github_pe.png\" alt=\"編程練習\" title=\"編程練習\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"c-primer-plus-6-programme-exercise\"><a href=\"#c-primer-plus-6-programme-exercise\" class=\"headerlink\" title=\"c primer plus 6 programme exercise\"></a>c primer plus 6 programme exercise</h1><p>本人在 c primer plus 中文第六版的<a href=\"https://github.com/ByXc01/cpp6-programme-exercise\" title=\"編程練習題\" target=\"_blank\" rel=\"external\">編程練習題</a>做的答案(不定期更新)。<br>如有需要的的朋友可自行clone。 部分源碼參考標準答案。<br>(可能本人做的不太好，望見諒。有錯請指出。有更好題的可以fork合並)<br>這已經算我在github 的一個大項目了，dalao 自行忽略。</p>","more":"<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/programme_exercise/github_pe.png\" alt=\"編程練習\" title=\"編程練習\"></p>"},{"title":"字符串和空字符","date":"2017-05-29T09:52:12.000Z","_content":"\n## 提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\n\n<!--more-->\n\n然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 `\\0` 的 bug 。\n``` c\n\t/* File: reverse.c\n\t * Author: ByXc\n\t * About: reverse\n\t * Version: 1.0\n\t * Compiler: gcc 5.1.0 for MinGw\n\t * Date: 20170513\n\t * Github: ByXc01\n\t * Blog: http://ByXc01.github.io\n\t */\n\n\t#include <stdio.h>\n\t#include <string.h>\n\n\tint main(void)\n    {\n        int i_count;\n        char ch_string[40];\n\n        printf(\"Please enter a string:\");\n        scanf(\"%s\", ch_string);\n\t\n        for (i_count = strlen(ch_string); i_count >= 0; i_count--)\n            printf(\"%c\", ch_string[i_count - 1]);        //i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)\n        printf(\"\\nThe all! \");\n\n        return 0;\n    }\n\t\n    /* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，\n     * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。\n     * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1\n     */\n```\n這個程序很簡單， 是 《*c primer plus*》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 `i_count - 1`， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 **“空格”**， 輸出如下：\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string1.png \"空字符\")\n\n**後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ `if (*(ch_string + 4) == ' ')` 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):**\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string2.png \"空字符\")\n\n因為折騰的蠻久的， 印象也特別深刻。\n\n## 接著在第十一章又見空字符\n``` c\n\tchar cha_string1[] = { 'B', 'y', 'X', 'c', '\\0' };\n\tchar cha_string2[] = { \"ByXc\" };\n\tchar * chp_string3 = { \"ByXc\" };\n\tchar * chp_string4 = \"ByXc\";\n\tchar cha_string3[5];\n\n\tcha_string[0] = 'B', \n\tcha_string[1] = 'y', \n\tcha_string[2] = 'X', \n\tcha_string[3] = 'c';\n```\n以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。\n\n**所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)**\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string3.png \"空字符\")\n\n讓我感覺想不通的還是程序清單 11.13 的輸出:\n```c\n\t/* nono.c -- 千萬不要模仿 */\n\t#include <stdio.h>\n\tint main(void)\n\t{\n        char side_a[] = \"Side A\";\n        char dont[] = { 'W', 'O', 'W', '!' };\n        char side_b[] = \"Side B\";\n        puts(dont);\t\t// dont 不是一個字符串， 應是一個字符數組\n\n        return 0;\n\t}\n```\n由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：\n```\n\tWOW!Side A\n```\n**我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。**\n\n***\n\n然而我的輸出為：\n\n```\n\tWOW!\n```\n\n然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 `gcc -S` 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。\n\n![沒有自動添加空字符啊](https://github.com/ByXc01/Blog-image/raw/master/null_character/character_array.png \"沒有自動添加空字符啊\")\n\n可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:\n\n![clang](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string4.png \"clang\")\n\n用 `clang -S` 編譯出來的彙編如下：\n\n```\n        .text\n        .file\t\"nono.c\"\n        .globl\tmain\n        .align\t16, 0x90\n        .type\tmain,@function\n\tmain:                                   # @main\n        .cfi_startproc\n\t# BB#0:\n        pushq\t%rbp\n\t.Ltmp0:\n        .cfi_def_cfa_offset 16\n\t.Ltmp1:\n        .cfi_offset %rbp, -16\n        movq\t%rsp, %rbp\n\t.Ltmp2:\n        .cfi_def_cfa_register %rbp\n        subq\t$32, %rsp\n        leaq\t-15(%rbp), %rdi\n        movl\t$0, -4(%rbp)\n        movl\t.Lmain.side_a, %eax\n        movl\t%eax, -11(%rbp)\n        movw\t.Lmain.side_a+4, %cx\n        movw\t%cx, -7(%rbp)\n        movb\t.Lmain.side_a+6, %dl\n        movb\t%dl, -5(%rbp)\n        movl\t.Lmain.dont, %eax\n        movl\t%eax, -15(%rbp)\n        movl\t.Lmain.sidw_b, %eax\n        movl\t%eax, -22(%rbp)\n        movw\t.Lmain.sidw_b+4, %cx\n        movw\t%cx, -18(%rbp)\n        movb\t.Lmain.sidw_b+6, %dl\n        movb\t%dl, -16(%rbp)\n        callq\tputs\n        xorl\t%esi, %esi\n        movl\t%eax, -28(%rbp)         # 4-byte Spill\n        movl\t%esi, %eax\n        addq\t$32, %rsp\n        popq\t%rbp\n        retq\n    .Lfunc_end0:\n        .size\tmain, .Lfunc_end0-main\n        .cfi_endproc\n\n        .type   .Lmian.side_a,@object   # @main.side_a\n        .section\t    .rodata.str1.1,\"aMS\",@progbits,1\n\n\t.Lmain.side_a:\n        .asciz\t\"Side A\"\n        .size\t.Lmain.side_a, 7\n\n        .type\t.Lmain.dont,@object     # @main.dont\n        .section\t.rodata.cst4,\"aM\",@progbits,4\n\t.Lmain.dont:\n        .ascii\t\"WOW!\"\n        .size\t.Lmain.dont, 4\n\n        .type\t.Lmain.sidw_b,@object   # @main.sidw_b\n        .section\t.rodata.str1.1,\"aMS\",@progbits,1\n\t.Lmain.sidw_b:\n        .asciz\t\"Sdie B\"\n        .size\t.Lmain.sidw_b, 7\n\n\n        .ident\t\"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)\"\n        .section\t\".note.GNU-stack\",\"\",@progbits\n```\n同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：\n```\n\t.Lmain.dont:\n        .ascii\t\"WOW!\"\n        .size\t.Lmain.dont, 4\n```\nsize 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。\n在 c 代碼總也可用 `sizeof` 來檢測是否有空字符:\n```c\n\tprintf(\"side_a: sizeof = %zd, strlen = %zd \\n\", sizeof （side_a), strlen(side_a));\n\tprintf(\"dont: sizeof = %zd, strlen = %zd \\n\", sizeof (dont), strlen(dont));\n\t// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符\n```\n反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。\n","source":"_posts/null-character/null_character.md","raw":"---\ntitle: 字符串和空字符\ndate: 2017-05-29 17:52:12\ntags: 空字符\n---\n\n## 提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\n\n<!--more-->\n\n然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 `\\0` 的 bug 。\n``` c\n\t/* File: reverse.c\n\t * Author: ByXc\n\t * About: reverse\n\t * Version: 1.0\n\t * Compiler: gcc 5.1.0 for MinGw\n\t * Date: 20170513\n\t * Github: ByXc01\n\t * Blog: http://ByXc01.github.io\n\t */\n\n\t#include <stdio.h>\n\t#include <string.h>\n\n\tint main(void)\n    {\n        int i_count;\n        char ch_string[40];\n\n        printf(\"Please enter a string:\");\n        scanf(\"%s\", ch_string);\n\t\n        for (i_count = strlen(ch_string); i_count >= 0; i_count--)\n            printf(\"%c\", ch_string[i_count - 1]);        //i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)\n        printf(\"\\nThe all! \");\n\n        return 0;\n    }\n\t\n    /* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，\n     * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。\n     * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1\n     */\n```\n這個程序很簡單， 是 《*c primer plus*》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 `i_count - 1`， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 **“空格”**， 輸出如下：\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string1.png \"空字符\")\n\n**後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ `if (*(ch_string + 4) == ' ')` 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):**\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string2.png \"空字符\")\n\n因為折騰的蠻久的， 印象也特別深刻。\n\n## 接著在第十一章又見空字符\n``` c\n\tchar cha_string1[] = { 'B', 'y', 'X', 'c', '\\0' };\n\tchar cha_string2[] = { \"ByXc\" };\n\tchar * chp_string3 = { \"ByXc\" };\n\tchar * chp_string4 = \"ByXc\";\n\tchar cha_string3[5];\n\n\tcha_string[0] = 'B', \n\tcha_string[1] = 'y', \n\tcha_string[2] = 'X', \n\tcha_string[3] = 'c';\n```\n以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。\n\n**所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)**\n\n![空字符](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string3.png \"空字符\")\n\n讓我感覺想不通的還是程序清單 11.13 的輸出:\n```c\n\t/* nono.c -- 千萬不要模仿 */\n\t#include <stdio.h>\n\tint main(void)\n\t{\n        char side_a[] = \"Side A\";\n        char dont[] = { 'W', 'O', 'W', '!' };\n        char side_b[] = \"Side B\";\n        puts(dont);\t\t// dont 不是一個字符串， 應是一個字符數組\n\n        return 0;\n\t}\n```\n由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：\n```\n\tWOW!Side A\n```\n**我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。**\n\n***\n\n然而我的輸出為：\n\n```\n\tWOW!\n```\n\n然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 `gcc -S` 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。\n\n![沒有自動添加空字符啊](https://github.com/ByXc01/Blog-image/raw/master/null_character/character_array.png \"沒有自動添加空字符啊\")\n\n可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:\n\n![clang](https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string4.png \"clang\")\n\n用 `clang -S` 編譯出來的彙編如下：\n\n```\n        .text\n        .file\t\"nono.c\"\n        .globl\tmain\n        .align\t16, 0x90\n        .type\tmain,@function\n\tmain:                                   # @main\n        .cfi_startproc\n\t# BB#0:\n        pushq\t%rbp\n\t.Ltmp0:\n        .cfi_def_cfa_offset 16\n\t.Ltmp1:\n        .cfi_offset %rbp, -16\n        movq\t%rsp, %rbp\n\t.Ltmp2:\n        .cfi_def_cfa_register %rbp\n        subq\t$32, %rsp\n        leaq\t-15(%rbp), %rdi\n        movl\t$0, -4(%rbp)\n        movl\t.Lmain.side_a, %eax\n        movl\t%eax, -11(%rbp)\n        movw\t.Lmain.side_a+4, %cx\n        movw\t%cx, -7(%rbp)\n        movb\t.Lmain.side_a+6, %dl\n        movb\t%dl, -5(%rbp)\n        movl\t.Lmain.dont, %eax\n        movl\t%eax, -15(%rbp)\n        movl\t.Lmain.sidw_b, %eax\n        movl\t%eax, -22(%rbp)\n        movw\t.Lmain.sidw_b+4, %cx\n        movw\t%cx, -18(%rbp)\n        movb\t.Lmain.sidw_b+6, %dl\n        movb\t%dl, -16(%rbp)\n        callq\tputs\n        xorl\t%esi, %esi\n        movl\t%eax, -28(%rbp)         # 4-byte Spill\n        movl\t%esi, %eax\n        addq\t$32, %rsp\n        popq\t%rbp\n        retq\n    .Lfunc_end0:\n        .size\tmain, .Lfunc_end0-main\n        .cfi_endproc\n\n        .type   .Lmian.side_a,@object   # @main.side_a\n        .section\t    .rodata.str1.1,\"aMS\",@progbits,1\n\n\t.Lmain.side_a:\n        .asciz\t\"Side A\"\n        .size\t.Lmain.side_a, 7\n\n        .type\t.Lmain.dont,@object     # @main.dont\n        .section\t.rodata.cst4,\"aM\",@progbits,4\n\t.Lmain.dont:\n        .ascii\t\"WOW!\"\n        .size\t.Lmain.dont, 4\n\n        .type\t.Lmain.sidw_b,@object   # @main.sidw_b\n        .section\t.rodata.str1.1,\"aMS\",@progbits,1\n\t.Lmain.sidw_b:\n        .asciz\t\"Sdie B\"\n        .size\t.Lmain.sidw_b, 7\n\n\n        .ident\t\"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)\"\n        .section\t\".note.GNU-stack\",\"\",@progbits\n```\n同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：\n```\n\t.Lmain.dont:\n        .ascii\t\"WOW!\"\n        .size\t.Lmain.dont, 4\n```\nsize 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。\n在 c 代碼總也可用 `sizeof` 來檢測是否有空字符:\n```c\n\tprintf(\"side_a: sizeof = %zd, strlen = %zd \\n\", sizeof （side_a), strlen(side_a));\n\tprintf(\"dont: sizeof = %zd, strlen = %zd \\n\", sizeof (dont), strlen(dont));\n\t// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符\n```\n反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。\n","slug":"null-character/null_character","published":1,"updated":"2017-08-24T13:14:32.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts97t000ht3lwg7wth361","content":"<h2 id=\"提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\"><a href=\"#提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\" class=\"headerlink\" title=\"提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\"></a>提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。</h2><a id=\"more\"></a>\n<p>然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 <code>\\0</code> 的 bug 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* File: reverse.c</span></div><div class=\"line\"> * Author: ByXc</div><div class=\"line\"> * About: reverse</div><div class=\"line\"> * Version: 1.0</div><div class=\"line\"> * Compiler: gcc 5.1.0 for MinGw</div><div class=\"line\"> * Date: 20170513</div><div class=\"line\"> * Github: ByXc01</div><div class=\"line\"> * Blog: http://ByXc01.github.io</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> i_count;</div><div class=\"line\">       <span class=\"keyword\">char</span> ch_string[<span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Please enter a string:\"</span>);</div><div class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, ch_string);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">for</span> (i_count = <span class=\"built_in\">strlen</span>(ch_string); i_count &gt;= <span class=\"number\">0</span>; i_count--)</div><div class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch_string[i_count - <span class=\"number\">1</span>]);        <span class=\"comment\">//i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)</span></div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe all! \"</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，</span></div><div class=\"line\">    * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。</div><div class=\"line\">    * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1</div><div class=\"line\">    */</div></pre></td></tr></table></figure></p>\n<p>這個程序很簡單， 是 《<em>c primer plus</em>》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 <code>i_count - 1</code>， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 <strong>“空格”</strong>， 輸出如下：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string1.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p><strong>後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ <code>if (*(ch_string + 4) == &#39; &#39;)</code> 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):</strong></p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string2.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>因為折騰的蠻久的， 印象也特別深刻。</p>\n<h2 id=\"接著在第十一章又見空字符\"><a href=\"#接著在第十一章又見空字符\" class=\"headerlink\" title=\"接著在第十一章又見空字符\"></a>接著在第十一章又見空字符</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> cha_string1[] = &#123; <span class=\"string\">'B'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'X'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'\\0'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string2[] = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string3 = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string4 = <span class=\"string\">\"ByXc\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string3[<span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\">cha_string[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">1</span>] = <span class=\"string\">'y'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">2</span>] = <span class=\"string\">'X'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">3</span>] = <span class=\"string\">'c'</span>;</div></pre></td></tr></table></figure>\n<p>以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。</p>\n<p><strong>所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)</strong></p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string3.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>讓我感覺想不通的還是程序清單 11.13 的輸出:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* nono.c -- 千萬不要模仿 */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">char</span> side_a[] = <span class=\"string\">\"Side A\"</span>;</div><div class=\"line\">       <span class=\"keyword\">char</span> dont[] = &#123; <span class=\"string\">'W'</span>, <span class=\"string\">'O'</span>, <span class=\"string\">'W'</span>, <span class=\"string\">'!'</span> &#125;;</div><div class=\"line\">       <span class=\"keyword\">char</span> side_b[] = <span class=\"string\">\"Side B\"</span>;</div><div class=\"line\">       <span class=\"built_in\">puts</span>(dont);\t\t<span class=\"comment\">// dont 不是一個字符串， 應是一個字符數組</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!Side A</div></pre></td></tr></table></figure></p>\n<p><strong>我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。</strong></p>\n<hr>\n<p>然而我的輸出為：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!</div></pre></td></tr></table></figure>\n<p>然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 <code>gcc -S</code> 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/character_array.png\" alt=\"沒有自動添加空字符啊\" title=\"沒有自動添加空字符啊\"></p>\n<p>可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string4.png\" alt=\"clang\" title=\"clang\"></p>\n<p>用 <code>clang -S</code> 編譯出來的彙編如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">       .text</div><div class=\"line\">       .file\t&quot;nono.c&quot;</div><div class=\"line\">       .globl\tmain</div><div class=\"line\">       .align\t16, 0x90</div><div class=\"line\">       .type\tmain,@function</div><div class=\"line\">main:                                   # @main</div><div class=\"line\">       .cfi_startproc</div><div class=\"line\"># BB#0:</div><div class=\"line\">       pushq\t%rbp</div><div class=\"line\">.Ltmp0:</div><div class=\"line\">       .cfi_def_cfa_offset 16</div><div class=\"line\">.Ltmp1:</div><div class=\"line\">       .cfi_offset %rbp, -16</div><div class=\"line\">       movq\t%rsp, %rbp</div><div class=\"line\">.Ltmp2:</div><div class=\"line\">       .cfi_def_cfa_register %rbp</div><div class=\"line\">       subq\t$32, %rsp</div><div class=\"line\">       leaq\t-15(%rbp), %rdi</div><div class=\"line\">       movl\t$0, -4(%rbp)</div><div class=\"line\">       movl\t.Lmain.side_a, %eax</div><div class=\"line\">       movl\t%eax, -11(%rbp)</div><div class=\"line\">       movw\t.Lmain.side_a+4, %cx</div><div class=\"line\">       movw\t%cx, -7(%rbp)</div><div class=\"line\">       movb\t.Lmain.side_a+6, %dl</div><div class=\"line\">       movb\t%dl, -5(%rbp)</div><div class=\"line\">       movl\t.Lmain.dont, %eax</div><div class=\"line\">       movl\t%eax, -15(%rbp)</div><div class=\"line\">       movl\t.Lmain.sidw_b, %eax</div><div class=\"line\">       movl\t%eax, -22(%rbp)</div><div class=\"line\">       movw\t.Lmain.sidw_b+4, %cx</div><div class=\"line\">       movw\t%cx, -18(%rbp)</div><div class=\"line\">       movb\t.Lmain.sidw_b+6, %dl</div><div class=\"line\">       movb\t%dl, -16(%rbp)</div><div class=\"line\">       callq\tputs</div><div class=\"line\">       xorl\t%esi, %esi</div><div class=\"line\">       movl\t%eax, -28(%rbp)         # 4-byte Spill</div><div class=\"line\">       movl\t%esi, %eax</div><div class=\"line\">       addq\t$32, %rsp</div><div class=\"line\">       popq\t%rbp</div><div class=\"line\">       retq</div><div class=\"line\">   .Lfunc_end0:</div><div class=\"line\">       .size\tmain, .Lfunc_end0-main</div><div class=\"line\">       .cfi_endproc</div><div class=\"line\"></div><div class=\"line\">       .type   .Lmian.side_a,@object   # @main.side_a</div><div class=\"line\">       .section\t    .rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\"></div><div class=\"line\">.Lmain.side_a:</div><div class=\"line\">       .asciz\t&quot;Side A&quot;</div><div class=\"line\">       .size\t.Lmain.side_a, 7</div><div class=\"line\"></div><div class=\"line\">       .type\t.Lmain.dont,@object     # @main.dont</div><div class=\"line\">       .section\t.rodata.cst4,&quot;aM&quot;,@progbits,4</div><div class=\"line\">.Lmain.dont:</div><div class=\"line\">       .ascii\t&quot;WOW!&quot;</div><div class=\"line\">       .size\t.Lmain.dont, 4</div><div class=\"line\"></div><div class=\"line\">       .type\t.Lmain.sidw_b,@object   # @main.sidw_b</div><div class=\"line\">       .section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\">.Lmain.sidw_b:</div><div class=\"line\">       .asciz\t&quot;Sdie B&quot;</div><div class=\"line\">       .size\t.Lmain.sidw_b, 7</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       .ident\t&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</div><div class=\"line\">       .section\t&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>\n<p>同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.Lmain.dont:</div><div class=\"line\">       .ascii\t&quot;WOW!&quot;</div><div class=\"line\">       .size\t.Lmain.dont, 4</div></pre></td></tr></table></figure></p>\n<p>size 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。<br>在 c 代碼總也可用 <code>sizeof</code> 來檢測是否有空字符:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"side_a: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> （side_a), <span class=\"built_in\">strlen</span>(side_a));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"dont: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> (dont), <span class=\"built_in\">strlen</span>(dont));</div><div class=\"line\"><span class=\"comment\">// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符</span></div></pre></td></tr></table></figure></p>\n<p>反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\"><a href=\"#提起空字符大家應該都不陌生，在-c-語言中，-沒有專門的字符串變量，-沒有-string-類型，-通常就用一個字符數組來存放一個字符串。\" class=\"headerlink\" title=\"提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。\"></a>提起空字符大家應該都不陌生，在 c 語言中， 沒有專門的字符串變量， 沒有 string 類型， 通常就用一個字符數組來存放一個字符串。</h2>","more":"<p>然而為什麼今天要專門寫一篇博客呢？ 原因是前不久第一次遇到一個關於空字符 <code>\\0</code> 的 bug 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* File: reverse.c</span></div><div class=\"line\"> * Author: ByXc</div><div class=\"line\"> * About: reverse</div><div class=\"line\"> * Version: 1.0</div><div class=\"line\"> * Compiler: gcc 5.1.0 for MinGw</div><div class=\"line\"> * Date: 20170513</div><div class=\"line\"> * Github: ByXc01</div><div class=\"line\"> * Blog: http://ByXc01.github.io</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> i_count;</div><div class=\"line\">       <span class=\"keyword\">char</span> ch_string[<span class=\"number\">40</span>];</div><div class=\"line\"></div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Please enter a string:\"</span>);</div><div class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, ch_string);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">for</span> (i_count = <span class=\"built_in\">strlen</span>(ch_string); i_count &gt;= <span class=\"number\">0</span>; i_count--)</div><div class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, ch_string[i_count - <span class=\"number\">1</span>]);        <span class=\"comment\">//i_count - 1, 是因为字符串后有一個空字符 \\0 (ASCII = 0)</span></div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe all! \"</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/* 關於空字符的問題：在minGW,codeblocks, visual studio 2015。輸出的是一個像空格一樣的字符，</span></div><div class=\"line\">    * 在手機c4droid, cide, aide, c4droid toolchain 的gcc5.2.0輸出空字符都是不可見得。。</div><div class=\"line\">    * 其他其他編譯器就不清楚了。。  so， 看情況是否使用i_count - 1</div><div class=\"line\">    */</div></pre></td></tr></table></figure></p>\n<p>這個程序很簡單， 是 《<em>c primer plus</em>》 第六章的一道編程練習題， 輸入一個字符串， 程序將字符串倒序輸出。 剛開始我沒有用 <code>i_count - 1</code>， 覺得有點奇怪，怎麼倒序輸出的字符串有一個 <strong>“空格”</strong>， 輸出如下：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string1.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p><strong>後來測試了幾個平台， 在 windows 環境下是會輸出一個類似格的字符， 為什麼說是類似呢？ <code>if (*(ch_string + 4) == &#39; &#39;)</code> 表達式為假。 在 Linux 環境下則輸出為不可見得（Windows 上用 msym2 輸出也是不可見的):</strong></p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string2.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>因為折騰的蠻久的， 印象也特別深刻。</p>\n<h2 id=\"接著在第十一章又見空字符\"><a href=\"#接著在第十一章又見空字符\" class=\"headerlink\" title=\"接著在第十一章又見空字符\"></a>接著在第十一章又見空字符</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> cha_string1[] = &#123; <span class=\"string\">'B'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'X'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'\\0'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string2[] = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string3 = &#123; <span class=\"string\">\"ByXc\"</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">char</span> * chp_string4 = <span class=\"string\">\"ByXc\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> cha_string3[<span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\">cha_string[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">1</span>] = <span class=\"string\">'y'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">2</span>] = <span class=\"string\">'X'</span>, </div><div class=\"line\">cha_string[<span class=\"number\">3</span>] = <span class=\"string\">'c'</span>;</div></pre></td></tr></table></figure>\n<p>以上的都是一個字符串， 在指定數組大小時， 要確保數組的元素個數要比字符串長度少 1 （為了容納空字符）。</p>\n<p><strong>所有未被使用的元素都會自動初始化為 0 （這裡的 0 指的是 char 形式的空字符， 不是數字字符 0)</strong></p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string3.png\" alt=\"空字符\" title=\"空字符\"></p>\n<p>讓我感覺想不通的還是程序清單 11.13 的輸出:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* nono.c -- 千萬不要模仿 */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"keyword\">char</span> side_a[] = <span class=\"string\">\"Side A\"</span>;</div><div class=\"line\">       <span class=\"keyword\">char</span> dont[] = &#123; <span class=\"string\">'W'</span>, <span class=\"string\">'O'</span>, <span class=\"string\">'W'</span>, <span class=\"string\">'!'</span> &#125;;</div><div class=\"line\">       <span class=\"keyword\">char</span> side_b[] = <span class=\"string\">\"Side B\"</span>;</div><div class=\"line\">       <span class=\"built_in\">puts</span>(dont);\t\t<span class=\"comment\">// dont 不是一個字符串， 應是一個字符數組</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由於 dont 缺少一個表示結束的空語句， 所以它不是一個字符串， 因此 puts() 不知道在何處停止。 它一直打印 dont 後面內存的內容， 知道發現一個空字符為止。 為了讓 puts() 能盡快能讀到空字符， 我們把 dont 放在 side_a 和 side_b 之間。 下面是該程序的一個運行示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!Side A</div></pre></td></tr></table></figure></p>\n<p><strong>我們使用的編譯器吧 side_a 數組存儲在 dont 數組之後， 所以 puts() 一直輸出至遇到 side_a 中的空字符。 你所用的編譯器輸出的內容可能不同， 這取決於編譯器如何在內存中存儲數據。 如果刪除程序的 side_a 和 side_b 數組會怎樣？ 通常內存中有許多空字符， 如果幸運的話， puts() 很快就會發現一個。 但是， 這樣做很不靠譜。</strong></p>\n<hr>\n<p>然而我的輸出為：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WOW!</div></pre></td></tr></table></figure>\n<p>然後我又在 armv7l（gcc 6.1.0), aarch64(gcc 6.1.0), x64(gcc 6.3.0) ubuntu(gcc 6.3.0)執行了一遍。結果都是 WOW! 無論是 puts() 還是 printf() 都是一樣。 用 <code>gcc -S</code> 編譯出來的彙編我也看了一下， 似乎編譯器也沒自動添加一個空字符啊。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/character_array.png\" alt=\"沒有自動添加空字符啊\" title=\"沒有自動添加空字符啊\"></p>\n<p>可能真是有關于編譯器吧， 我用 ubuntu(clang 3.8.0) 輸出跟書上一樣:</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/null_character/null_string4.png\" alt=\"clang\" title=\"clang\"></p>\n<p>用 <code>clang -S</code> 編譯出來的彙編如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">       .text</div><div class=\"line\">       .file\t&quot;nono.c&quot;</div><div class=\"line\">       .globl\tmain</div><div class=\"line\">       .align\t16, 0x90</div><div class=\"line\">       .type\tmain,@function</div><div class=\"line\">main:                                   # @main</div><div class=\"line\">       .cfi_startproc</div><div class=\"line\"># BB#0:</div><div class=\"line\">       pushq\t%rbp</div><div class=\"line\">.Ltmp0:</div><div class=\"line\">       .cfi_def_cfa_offset 16</div><div class=\"line\">.Ltmp1:</div><div class=\"line\">       .cfi_offset %rbp, -16</div><div class=\"line\">       movq\t%rsp, %rbp</div><div class=\"line\">.Ltmp2:</div><div class=\"line\">       .cfi_def_cfa_register %rbp</div><div class=\"line\">       subq\t$32, %rsp</div><div class=\"line\">       leaq\t-15(%rbp), %rdi</div><div class=\"line\">       movl\t$0, -4(%rbp)</div><div class=\"line\">       movl\t.Lmain.side_a, %eax</div><div class=\"line\">       movl\t%eax, -11(%rbp)</div><div class=\"line\">       movw\t.Lmain.side_a+4, %cx</div><div class=\"line\">       movw\t%cx, -7(%rbp)</div><div class=\"line\">       movb\t.Lmain.side_a+6, %dl</div><div class=\"line\">       movb\t%dl, -5(%rbp)</div><div class=\"line\">       movl\t.Lmain.dont, %eax</div><div class=\"line\">       movl\t%eax, -15(%rbp)</div><div class=\"line\">       movl\t.Lmain.sidw_b, %eax</div><div class=\"line\">       movl\t%eax, -22(%rbp)</div><div class=\"line\">       movw\t.Lmain.sidw_b+4, %cx</div><div class=\"line\">       movw\t%cx, -18(%rbp)</div><div class=\"line\">       movb\t.Lmain.sidw_b+6, %dl</div><div class=\"line\">       movb\t%dl, -16(%rbp)</div><div class=\"line\">       callq\tputs</div><div class=\"line\">       xorl\t%esi, %esi</div><div class=\"line\">       movl\t%eax, -28(%rbp)         # 4-byte Spill</div><div class=\"line\">       movl\t%esi, %eax</div><div class=\"line\">       addq\t$32, %rsp</div><div class=\"line\">       popq\t%rbp</div><div class=\"line\">       retq</div><div class=\"line\">   .Lfunc_end0:</div><div class=\"line\">       .size\tmain, .Lfunc_end0-main</div><div class=\"line\">       .cfi_endproc</div><div class=\"line\"></div><div class=\"line\">       .type   .Lmian.side_a,@object   # @main.side_a</div><div class=\"line\">       .section\t    .rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\"></div><div class=\"line\">.Lmain.side_a:</div><div class=\"line\">       .asciz\t&quot;Side A&quot;</div><div class=\"line\">       .size\t.Lmain.side_a, 7</div><div class=\"line\"></div><div class=\"line\">       .type\t.Lmain.dont,@object     # @main.dont</div><div class=\"line\">       .section\t.rodata.cst4,&quot;aM&quot;,@progbits,4</div><div class=\"line\">.Lmain.dont:</div><div class=\"line\">       .ascii\t&quot;WOW!&quot;</div><div class=\"line\">       .size\t.Lmain.dont, 4</div><div class=\"line\"></div><div class=\"line\">       .type\t.Lmain.sidw_b,@object   # @main.sidw_b</div><div class=\"line\">       .section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</div><div class=\"line\">.Lmain.sidw_b:</div><div class=\"line\">       .asciz\t&quot;Sdie B&quot;</div><div class=\"line\">       .size\t.Lmain.sidw_b, 7</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">       .ident\t&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</div><div class=\"line\">       .section\t&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>\n<p>同樣也的， 好像也沒有自動加空字符。 雖然我也看不懂彙編。 但很明顯的是這一句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.Lmain.dont:</div><div class=\"line\">       .ascii\t&quot;WOW!&quot;</div><div class=\"line\">       .size\t.Lmain.dont, 4</div></pre></td></tr></table></figure></p>\n<p>size 只有 4， 可以說明沒有加空字符。 其它兩個都加了， 所以 size 才是 7。<br>在 c 代碼總也可用 <code>sizeof</code> 來檢測是否有空字符:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"side_a: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> （side_a), <span class=\"built_in\">strlen</span>(side_a));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"dont: sizeof = %zd, strlen = %zd \\n\"</span>, <span class=\"keyword\">sizeof</span> (dont), <span class=\"built_in\">strlen</span>(dont));</div><div class=\"line\"><span class=\"comment\">// 因為 sizeof 會將空字符也納入計算， 而 strlen() 則會忽略空字符</span></div></pre></td></tr></table></figure></p>\n<p>反正知道字符數組和字符串的區別就好了。 太底層我也搞不懂， 因為也沒學過彙編和 gdb 。</p>"},{"title":"ByXc's blog","date":"2017-05-06T08:55:29.000Z","_content":"## Hello , Welcome to ByXc's blog.\n\n<!--more-->\n\n* 這是用 hexo + github 搭建的個人博客，\n* 有空會發一些個人學習的一些文章博客。\n* 身爲初學者， 老鳥無噴啊。\n* 先來一段 c語言的 Hello World 再說。\n\n``` c\n    #inlcude <stdio.h>\n    int main(void)\n    {\n        printf(\"hello world \\n\");\n\n        return 0;\n    }\n```\n***\n\n* 初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。\n* 附上logo：\n\n ![ByXc](https://github.com/ByXc01/Blog-image/raw/master/logo/logo.jpg \"ByXc\")\n","source":"_posts/hello-byxc/hello-byxc.md","raw":"---\ntitle: ByXc's blog             # 可以改成中文的， 如\"你好世界\"\ndate: 2017-05-06 16:55:29\ntags: hello\n---\n## Hello , Welcome to ByXc's blog.\n\n<!--more-->\n\n* 這是用 hexo + github 搭建的個人博客，\n* 有空會發一些個人學習的一些文章博客。\n* 身爲初學者， 老鳥無噴啊。\n* 先來一段 c語言的 Hello World 再說。\n\n``` c\n    #inlcude <stdio.h>\n    int main(void)\n    {\n        printf(\"hello world \\n\");\n\n        return 0;\n    }\n```\n***\n\n* 初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。\n* 附上logo：\n\n ![ByXc](https://github.com/ByXc01/Blog-image/raw/master/logo/logo.jpg \"ByXc\")\n","slug":"hello-byxc/hello-byxc","published":1,"updated":"2017-08-24T09:28:28.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts99o000tt3lwyc5jfe28","content":"<h2 id=\"Hello-Welcome-to-ByXc’s-blog\"><a href=\"#Hello-Welcome-to-ByXc’s-blog\" class=\"headerlink\" title=\"Hello , Welcome to ByXc’s blog.\"></a>Hello , Welcome to ByXc’s blog.</h2><a id=\"more\"></a>\n<ul>\n<li>這是用 hexo + github 搭建的個人博客，</li>\n<li>有空會發一些個人學習的一些文章博客。</li>\n<li>身爲初學者， 老鳥無噴啊。</li>\n<li>先來一段 c語言的 Hello World 再說。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#inlcude <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world \\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。</li>\n<li><p>附上logo：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/logo/logo.jpg\" alt=\"ByXc\" title=\"ByXc\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Hello-Welcome-to-ByXc’s-blog\"><a href=\"#Hello-Welcome-to-ByXc’s-blog\" class=\"headerlink\" title=\"Hello , Welcome to ByXc’s blog.\"></a>Hello , Welcome to ByXc’s blog.</h2>","more":"<ul>\n<li>這是用 hexo + github 搭建的個人博客，</li>\n<li>有空會發一些個人學習的一些文章博客。</li>\n<li>身爲初學者， 老鳥無噴啊。</li>\n<li>先來一段 c語言的 Hello World 再說。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#inlcude <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world \\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>初學者會敲個 hello world 不丟人把，剛接觸markdown寫的不好也就這樣了。</li>\n<li><p>附上logo：</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/logo/logo.jpg\" alt=\"ByXc\" title=\"ByXc\"></p>\n</li>\n</ul>"},{"title":"編譯 gcc7.1.0","date":"2017-06-23T08:49:46.000Z","_content":"\n## 下載依賴包\n最近在看博客的時候無意中看到 `gcc 7.1.0` 出來了， 就想更新一下。 因之前我也嘗試編譯了 `gcc 6.3.0`\n\n<!--more-->\n\n我是在[清華大學鏡像源](https://mirrors.tuna.tsinghua.edu.cn/ \"清華大學鏡像源\") 下載了 gmp、mpfr、mpc、gcc的包。因第一次是直接在下在[gnu官網](http://ftp.gnu.org/gnu/ \"gnu官網\")，下載實在是太慢了。 而且上次編譯的時候還是直接是\n``` bash\n    ./download_prerequisites\n    ./configure\n    make\n    make install\n```\n因爲這樣還要下載依賴包。 所以這次嘗試一下離線編譯， 自己下載依賴包編譯。 安裝過程我就不寫了， 因本人也是初學者。 感謝搜索引擎和[csdn](http://www.csdn.net/ \"csdn\")， 都是自己找的教程。 在羣問人屢招忽視， 靠人不如靠己啊。\n\n## 編譯完後\n`make` 過程很久, 中間也有出錯過， 經羣友提醒再次編譯， 而且我還在虛擬機裏面裝的。裝了兩個版本的 `gcc` 了，都沒有一次直接通過的。 裝完後在[github](https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md \"github\")找了一個 `c++17` 特性的代碼測試了一下， 因本人還不會 `c++` 拷貝一個完整簡單的。代碼如下:\n\n``` c\n    /* c++17 feature */\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    struct Foo\n    {\n        int x = 0;\n        std::string str = \"wrold\";\n        ~Foo()\n        {\n            std::cout<<str<<endl;\n        }\n    };\n\n    int main(void)\n    {\n        auto [i, s] = Foo();\n        std::cout<<\"hello \"<<endl;\n        s = \"structured bindings\";\n\n        return 0;\n    }\n```\n\n## 最後附上截圖\n\n編譯命令 `g++ -std=c++1z -Wall source_file.c -o program.out` 其中的 `-std=c++1z` 是因編譯的是 `c++17` 特性的程序。\n\n![source_file](https://github.com/ByXc01/Blog-image/raw/master/compilation_gcc/c%2B%2B17_feature.png \"source\")\n","source":"_posts/compilation-gcc/compilation-gcc.md","raw":"---\ntitle: 編譯 gcc7.1.0\ndate: 2017-06-23 16:49:46\ntags: gcc\n---\n\n## 下載依賴包\n最近在看博客的時候無意中看到 `gcc 7.1.0` 出來了， 就想更新一下。 因之前我也嘗試編譯了 `gcc 6.3.0`\n\n<!--more-->\n\n我是在[清華大學鏡像源](https://mirrors.tuna.tsinghua.edu.cn/ \"清華大學鏡像源\") 下載了 gmp、mpfr、mpc、gcc的包。因第一次是直接在下在[gnu官網](http://ftp.gnu.org/gnu/ \"gnu官網\")，下載實在是太慢了。 而且上次編譯的時候還是直接是\n``` bash\n    ./download_prerequisites\n    ./configure\n    make\n    make install\n```\n因爲這樣還要下載依賴包。 所以這次嘗試一下離線編譯， 自己下載依賴包編譯。 安裝過程我就不寫了， 因本人也是初學者。 感謝搜索引擎和[csdn](http://www.csdn.net/ \"csdn\")， 都是自己找的教程。 在羣問人屢招忽視， 靠人不如靠己啊。\n\n## 編譯完後\n`make` 過程很久, 中間也有出錯過， 經羣友提醒再次編譯， 而且我還在虛擬機裏面裝的。裝了兩個版本的 `gcc` 了，都沒有一次直接通過的。 裝完後在[github](https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md \"github\")找了一個 `c++17` 特性的代碼測試了一下， 因本人還不會 `c++` 拷貝一個完整簡單的。代碼如下:\n\n``` c\n    /* c++17 feature */\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    struct Foo\n    {\n        int x = 0;\n        std::string str = \"wrold\";\n        ~Foo()\n        {\n            std::cout<<str<<endl;\n        }\n    };\n\n    int main(void)\n    {\n        auto [i, s] = Foo();\n        std::cout<<\"hello \"<<endl;\n        s = \"structured bindings\";\n\n        return 0;\n    }\n```\n\n## 最後附上截圖\n\n編譯命令 `g++ -std=c++1z -Wall source_file.c -o program.out` 其中的 `-std=c++1z` 是因編譯的是 `c++17` 特性的程序。\n\n![source_file](https://github.com/ByXc01/Blog-image/raw/master/compilation_gcc/c%2B%2B17_feature.png \"source\")\n","slug":"compilation-gcc/compilation-gcc","published":1,"updated":"2017-08-24T12:34:54.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj78ts9a7000ut3lwjkmvyap8","content":"<h2 id=\"下載依賴包\"><a href=\"#下載依賴包\" class=\"headerlink\" title=\"下載依賴包\"></a>下載依賴包</h2><p>最近在看博客的時候無意中看到 <code>gcc 7.1.0</code> 出來了， 就想更新一下。 因之前我也嘗試編譯了 <code>gcc 6.3.0</code></p>\n<a id=\"more\"></a>\n<p>我是在<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\" title=\"清華大學鏡像源\" target=\"_blank\" rel=\"external\">清華大學鏡像源</a> 下載了 gmp、mpfr、mpc、gcc的包。因第一次是直接在下在<a href=\"http://ftp.gnu.org/gnu/\" title=\"gnu官網\" target=\"_blank\" rel=\"external\">gnu官網</a>，下載實在是太慢了。 而且上次編譯的時候還是直接是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">./download_prerequisites</div><div class=\"line\">./configure</div><div class=\"line\">make</div><div class=\"line\">make install</div></pre></td></tr></table></figure></p>\n<p>因爲這樣還要下載依賴包。 所以這次嘗試一下離線編譯， 自己下載依賴包編譯。 安裝過程我就不寫了， 因本人也是初學者。 感謝搜索引擎和<a href=\"http://www.csdn.net/\" title=\"csdn\" target=\"_blank\" rel=\"external\">csdn</a>， 都是自己找的教程。 在羣問人屢招忽視， 靠人不如靠己啊。</p>\n<h2 id=\"編譯完後\"><a href=\"#編譯完後\" class=\"headerlink\" title=\"編譯完後\"></a>編譯完後</h2><p><code>make</code> 過程很久, 中間也有出錯過， 經羣友提醒再次編譯， 而且我還在虛擬機裏面裝的。裝了兩個版本的 <code>gcc</code> 了，都沒有一次直接通過的。 裝完後在<a href=\"https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md\" title=\"github\" target=\"_blank\" rel=\"external\">github</a>找了一個 <code>c++17</code> 特性的代碼測試了一下， 因本人還不會 <code>c++</code> 拷貝一個完整簡單的。代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* c++17 feature */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> str = <span class=\"string\">\"wrold\"</span>;</div><div class=\"line\">    ~Foo()</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">auto</span> [i, s] = Foo();</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    s = <span class=\"string\">\"structured bindings\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"最後附上截圖\"><a href=\"#最後附上截圖\" class=\"headerlink\" title=\"最後附上截圖\"></a>最後附上截圖</h2><p>編譯命令 <code>g++ -std=c++1z -Wall source_file.c -o program.out</code> 其中的 <code>-std=c++1z</code> 是因編譯的是 <code>c++17</code> 特性的程序。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/compilation_gcc/c%2B%2B17_feature.png\" alt=\"source_file\" title=\"source\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"下載依賴包\"><a href=\"#下載依賴包\" class=\"headerlink\" title=\"下載依賴包\"></a>下載依賴包</h2><p>最近在看博客的時候無意中看到 <code>gcc 7.1.0</code> 出來了， 就想更新一下。 因之前我也嘗試編譯了 <code>gcc 6.3.0</code></p>","more":"<p>我是在<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\" title=\"清華大學鏡像源\" target=\"_blank\" rel=\"external\">清華大學鏡像源</a> 下載了 gmp、mpfr、mpc、gcc的包。因第一次是直接在下在<a href=\"http://ftp.gnu.org/gnu/\" title=\"gnu官網\" target=\"_blank\" rel=\"external\">gnu官網</a>，下載實在是太慢了。 而且上次編譯的時候還是直接是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">./download_prerequisites</div><div class=\"line\">./configure</div><div class=\"line\">make</div><div class=\"line\">make install</div></pre></td></tr></table></figure></p>\n<p>因爲這樣還要下載依賴包。 所以這次嘗試一下離線編譯， 自己下載依賴包編譯。 安裝過程我就不寫了， 因本人也是初學者。 感謝搜索引擎和<a href=\"http://www.csdn.net/\" title=\"csdn\" target=\"_blank\" rel=\"external\">csdn</a>， 都是自己找的教程。 在羣問人屢招忽視， 靠人不如靠己啊。</p>\n<h2 id=\"編譯完後\"><a href=\"#編譯完後\" class=\"headerlink\" title=\"編譯完後\"></a>編譯完後</h2><p><code>make</code> 過程很久, 中間也有出錯過， 經羣友提醒再次編譯， 而且我還在虛擬機裏面裝的。裝了兩個版本的 <code>gcc</code> 了，都沒有一次直接通過的。 裝完後在<a href=\"https://github.com/tvaneerd/cpp17_in_TTs/blob/master/ALL_IN_ONE.md\" title=\"github\" target=\"_blank\" rel=\"external\">github</a>找了一個 <code>c++17</code> 特性的代碼測試了一下， 因本人還不會 <code>c++</code> 拷貝一個完整簡單的。代碼如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* c++17 feature */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> str = <span class=\"string\">\"wrold\"</span>;</div><div class=\"line\">    ~Foo()</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;str&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">auto</span> [i, s] = Foo();</div><div class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"hello \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    s = <span class=\"string\">\"structured bindings\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"最後附上截圖\"><a href=\"#最後附上截圖\" class=\"headerlink\" title=\"最後附上截圖\"></a>最後附上截圖</h2><p>編譯命令 <code>g++ -std=c++1z -Wall source_file.c -o program.out</code> 其中的 <code>-std=c++1z</code> 是因編譯的是 <code>c++17</code> 特性的程序。</p>\n<p><img src=\"https://github.com/ByXc01/Blog-image/raw/master/compilation_gcc/c%2B%2B17_feature.png\" alt=\"source_file\" title=\"source\"></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj78ts8zf0000t3lwfeg7bl3h","tag_id":"cj78ts90h0001t3lwvbx51wos","_id":"cj78ts9180002t3lwaxu5f79f"},{"post_id":"cj78ts9520003t3lwt8k13ril","tag_id":"cj78ts95l0005t3lw38wdtbrb","_id":"cj78ts96y000at3lwlx5rg9nl"},{"post_id":"cj78ts96z000bt3lwc68tz0st","tag_id":"cj78ts96w0009t3lwhf46hsyt","_id":"cj78ts97g000et3lwiqkybees"},{"post_id":"cj78ts95f0004t3lw073644qx","tag_id":"cj78ts96w0009t3lwhf46hsyt","_id":"cj78ts97r000gt3lwtnvpmnfc"},{"post_id":"cj78ts95n0006t3lwcwcscknf","tag_id":"cj78ts97f000dt3lwingto6w7","_id":"cj78ts98s000jt3lwez8upc96"},{"post_id":"cj78ts9610007t3lwzqcrbf3o","tag_id":"cj78ts98m000it3lwd6rg1cae","_id":"cj78ts98v000lt3lwx9q8dn3x"},{"post_id":"cj78ts96q0008t3lw6vdfbgr5","tag_id":"cj78ts98u000kt3lwpp2gqxcp","_id":"cj78ts98y000nt3lwo2147yyh"},{"post_id":"cj78ts979000ct3lw964x3xs6","tag_id":"cj78ts98x000mt3lwl7jvm9d6","_id":"cj78ts993000pt3lww1gv4wi9"},{"post_id":"cj78ts97i000ft3lwgg33ehtp","tag_id":"cj78ts98z000ot3lweaw5jk61","_id":"cj78ts99e000rt3lwqc0ak5j5"},{"post_id":"cj78ts97t000ht3lwg7wth361","tag_id":"cj78ts997000qt3lw3k6u25rj","_id":"cj78ts99e000st3lwwp0zyf7y"},{"post_id":"cj78ts99o000tt3lwyc5jfe28","tag_id":"cj78ts9an000vt3lwv1r7fawl","_id":"cj78ts9az000xt3lwr946f7gp"},{"post_id":"cj78ts9a7000ut3lwjkmvyap8","tag_id":"cj78ts9aq000wt3lwlzvdy06o","_id":"cj78ts9b0000yt3lws3i2qeuf"}],"Tag":[{"name":"Hello World","_id":"cj78ts90h0001t3lwvbx51wos"},{"name":"_Noreturn","_id":"cj78ts95l0005t3lw38wdtbrb"},{"name":"隨筆","_id":"cj78ts96w0009t3lwhf46hsyt"},{"name":"life","_id":"cj78ts97f000dt3lwingto6w7"},{"name":"源碼 反碼 補碼","_id":"cj78ts98m000it3lwd6rg1cae"},{"name":"尾遞歸","_id":"cj78ts98u000kt3lwpp2gqxcp"},{"name":"gets_s","_id":"cj78ts98x000mt3lwl7jvm9d6"},{"name":"github","_id":"cj78ts98z000ot3lweaw5jk61"},{"name":"空字符","_id":"cj78ts997000qt3lw3k6u25rj"},{"name":"hello","_id":"cj78ts9an000vt3lwv1r7fawl"},{"name":"gcc","_id":"cj78ts9aq000wt3lwlzvdy06o"}]}}