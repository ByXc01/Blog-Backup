---
title: 關於尾遞歸的問題
date: 2017-05-26 20:43:33
tags: 尾遞歸
---

### （我們今天來談談尾遞歸的問題）

***

### c primer plus 定義

**尾遞歸**， 這是本人學到遞歸的一個疑惑點。 在 《*c primer plus* 》中文第六版中，

尾遞歸的是這樣定義的：

**“最簡單的遞歸形式是把遞歸調用置於函數的末尾， 即正好在`return`語句之前。這種形式的遞歸被稱為尾遞歸(tail recursion), 因為遞歸調用在函數的末尾。尾遞歸是最簡單的遞歸形式，因為它相當於循環。”**

<!--more-->

---

接著書上給的尾遞歸例子是這樣的:


``` c
    long rfact(int n)
    {
        long ans;

        if (n > 0)
            ans = n * rfact(n - 1);
        else
            ans = 1;

        return ans;
    }

```

這個版本，個人覺得不夠好。手動優化了一下。因為對rfact()的單次遞歸調用是函數返回前最後一條的執行語句。在rfact()中碰巧最後一條語句也是對rfact()的調用(引用百度百科， 對於《*c primer plus*》的定義，也是算尾遞歸吧)：

``` c
	long rfact(int n)
	{
		if (n <= 1)
            return 1;

		return rfact(n - 1) * n;		// 省略不必要的存儲
	}
```
* * *

別以為就這樣就完事了， 那時候我對**尾遞歸**還不是太理解(現在也不是很理解），隨後即上網查， 不搜不知道， 一搜嚇一跳。這跟書本的尾遞歸不太一樣啊。。。

但是在百度百科是這樣定義的：

### 百度百科定義

**“如果一個函數中所有遞歸形式的調用都出現在函數的末尾，我們稱這個遞歸函數是尾遞歸的。當遞歸調用時整個函數體最後執行的語句且他的返回值不屬於表達式的一部分時，這個遞歸調用就是尾遞歸。尾遞歸函數的特點是在回歸過程中不用做任何操作，這個特性很重要，因為大多數現待的編譯器會利用這種特性點自動生成優化的代碼”**

(又是另一個觀點啊， 對於我這種理解能力差的初學者真是想不通) 示例代碼如下：

``` c
	int facttail(int n, int a)

	{
		/* Compute a factorialina tail - recursive manner */

		if (n < 0)
            return 0;
		else if (n == 0)
            return 1;
		else if (n == 1)
            return a;
		else
            return facttail(n - 1, n * a);
	}
```

**“這種定義還需要接受第二個參數a, 除此之外並沒有太大區別。a（初始化為1）維護遞歸層次的深度。這就讓我們避免了每次還需要將返回值再乘以n。然而，在每次遞歸調用中，令 a = a * n 並且 n =  n - 1。繼續遞歸調用，直到 n = 1， 這是滿足結束條件，此時直接返回 a 即可。”**

沒錯，照百度百科的定義這個代碼才是**尾遞歸**， 算法也比前兩個例子簡便要好許多。

- - -

### 博客園 twoon 的博客截取

在博客園看到一個不錯的博文[說說尾遞歸](http://www.cnblogs.com/catch/p/3495450.html "說說尾遞歸")

博文中的**尾遞歸**的代碼跟**百度百科的示例代碼差不多。接下我將主要部分再寫一下吧， 望原作者勿怪。

### 什麼是尾遞歸

什麼事尾遞歸(tail recursion)呢？顧名思義，就是種“不一樣”的遞歸，說到它不一樣，就得說說一般的遞歸，比如下面的求階乘(factorial)，教課書上會告訴我們，如果這個函數的深度太深，很容易棧溢出。

``` c
	// 先不考慮溢出的問題
	int func(int n)
	{
		if (n <= 1)
            return 1;

		return (n * func(n - 1));
	}
```

原因很多人都知道的，讓我們先回顧一下函數調用的大概過程:

*  1: 調用開始前，調用方（或函數本身）會往棧上壓相關的數據，參數，返回地址，局部變量等。

*  2: 執行函數。

*  3: 清理棧上的相關的數據，返回。(據我所了解好像並沒有清理, 只是esp移動了而已。詳細的請自行查找“函數棧”， 此文不講函數棧，可能等我學會 **gdb** 和一點 **彙編** 再作深入研究)

因此，在函數 A 執行的時候，如果在第二步中，它又調用一個函數 B, B 有調用 C ... 棧就不斷地增長地裝入數據，當這個調用鏈很深的時候，棧就很容易就滿了，這就是一般遞歸函數所面臨的大問題。

**而尾遞歸在某些語言上，能避免上述所說的問題，注意是某些語言上，尾遞歸本身并不能消除函數調用棧過長的問題，那什麼是尾遞歸呢？在上面寫一般遞歸函數 func() 中, 我們可以看到， fun(n) 是依賴于 func(n - 1) 的，func(n) 只有得到 func(n - 1) 的結果之後，才能計算它自己的返回值，因此理論上，在 func(n - 1) 返回之前， func(n), 不能結束返回。因此 func(n) 就必須保留它在棧上的數據，直到 func(n - 1) 先返回， 而尾遞歸的實例可以在編譯器的幫助下，消除這個限制:**

``` c
	// 先不考慮溢出
	int tail_func(int n, int res)
	{
		if (n <= 1)
            return res;

		return tail_func(n - 1, n * res);
	}
```

``` c
	// 向下面這樣調用
	tail_func(10000000000, 1);
```

從上可以看出尾遞歸把返回結果放到了調用的參數里。這個細小的變化導致，tail_fun(n, res) 不必像以前一樣，非要拿到了 tail_func(n - 1, n \* res) 的返回值，才能計算它自己的返回結果 -- 它就完全等於 tail_fun(n - 1, n \* res) 的返回值。 因此理論上: tail_func(n) 在調用 tail_func(n - 1） 前， 是完全就可以摧毀自己放在棧上的東西。

這就是為什麼尾遞歸如果在得到編譯器的幫助下，是完全避免溢出的原因： 每一個函數在調用下一個函數之前，都能做到先把當前自己佔用的棧先釋放了， 尾遞歸的調用鏈上可以做到只有一個函數在使用棧，因此可以無限地調用！

### 尾遞歸的調用棧優化特性

相信讀者都注意到了，我一直強調，尾遞歸的實現依賴於編譯器的幫助（或者說語言的規定），為什麼這樣說呢？先看下面的程序：

``` c
	#include <stdio.h>

	int tail_func(int n, int res)
	{
		if (n <= 1)
            return res;

		return tail_func(n - 1, n * res);
	}

	int main(void)
	{
		int dummy[1014 * 1024];		// 盡可能佔用棧

		tail_func(2048 * 2048, 1);

		return 0;
	}
```

上面的這個程序在開了編譯優化和沒開編譯優化的情況下編譯出來的結果是不一樣的，如果不開啟優化，直接 `gcc -Wall factorial_tail.c `編譯讓後運行的話，程序會包棧崩潰。

沒開編譯優化：

![沒開編譯優化](http://opkl2tvjd.bkt.clouddn.com/not_o2.png "沒開編譯優化")

但如果開優化的話： `gcc -Wall -O2 factorial_tail.c`， 上面的程序最後就能正常運行。

開了`-O2` 編譯優化:

![開了 -O2 編譯優化](http://opkl2tvjd.bkt.clouddn.com/02.png "開了 -O2 編譯優化")

**這裡面的原因就在於，尾遞歸的寫法只是具備了使用當前函數在調用下一個函數前把當前占有的棧銷毀，但是會不會真的這樣做，具體要看編譯器是否這樣做，如果在語言層面上，沒有規定要優化這種為調用，那編譯器就可以有自己的選擇來做不同的實現，在這種情況下，尾遞歸就不能一定解決一般遞歸的問題。**

我們可以先看看上面的例子在開優化與未開優化的情況，編譯出來的彙編代碼有設麼不同，首先是沒開優化編譯出來factorial_tail.c 的匯編代碼 

![沒開優化彙編](http://opkl2tvjd.bkt.clouddn.com/not_no2s.png "沒開優化彙編")

**注意上面 `tail_func` 函數中的 `call` 語句， call 指令就是直接進行了函數調用，它會先壓棧，然後再 `jmp` 去 `tail_func`， 而當前額棧還在用！就是說，尾遞歸的作用沒有發揮。**

我們在看看開了優化得到的彙編:

![開了優化彙編](http://opkl2tvjd.bkt.clouddn.com/o2eds.png "開了優化彙編")

注意 `tail_func` 函數彙編中 `imull %ecx, %eax` 和 `jne .L3`。`tail_func()` 裡面沒有函數調用！它只是把當前函數的第二個參數改了一下，直接就又跳到函數開始的地方。此處的實現本質其實就是： 下一個函數調用繼續延用了當前的棧!

這就是尾遞歸所能帶來的效果： 控制棧的增長，且減小壓棧，程序運行的效率也可能更高。。

## 結束語

好了， 以上就是《c primer plus》 和 網上所說的尾遞歸（是不一樣的），本人更傾向于後者， 覺得可通過編譯優化提高效率。

還有的就是，上面的彙編代碼小聰是看不懂了，只是當個搬運工。。

**最後提一下，本人要盡快把 《c primer plus》 看完。所以也并有什麼時間寫博客（其實以我的能力也寫不出什麼博客)**

#  Happy Birthday to myself.
