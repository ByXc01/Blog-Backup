---
title: binary
date: 2017-08-23 20:27:57
tags: 源碼 反碼 補碼
---
# 原碼、反碼、補碼
此博客部分轉載 [计算机为什么选用二进制补码（1）---原码、反码、补码](http://blog.csdn.net/hittata/article/details/9108323 "千年的塔")

## 1.總的概念
(1): 數在計算機中是以二進制形式表示的；
(2): 數分為有符號數和無符號數；
(3): 原碼、反碼、補碼都是有定點數的表示方法；
(4): 無符號數全部按正數處理；
(5): 一個有符號定點數的最高位，0是正，1是負；
<!--more-->

## 2.反碼，補碼定義
**正數：**
原碼 = 反碼 = 補碼

**負數：**
原碼；
反碼 = 其原碼除符號位之外的各位求反；
補碼 = 反碼 + 1 （如果 + 1 之後又進位的， 要一直往前進位， 包括符號位；

## 3.運算示例

(這裡按照一字節(byte)八位(Bit)表示)
正零： 0000 0000
負零： 1000 0000
其實這兩個數都是 0， 但它們的原碼卻有不同的表示。
但它們的補碼是一樣的， 都是 0000 0000。
**特別注意，如果 +1 之後有進位的， 要一直往前進位， 包括符號位!(這和反碼不同)**

[1000 0000]補
= [1000 0000]反 + 1
= 1111 1111 + 1
= (1)0000 0000
= 0000 0000（最高位溢出了，符號位變成了0)

### 提一下補碼的兩個特性
**(1): 負補碼轉原碼的方法是： 取補碼的反碼+1；**
**(2): 求補碼相反數的方法是： 反轉每一位(包括符號位，即0變1，1變0），然後加1。)；**
例1： 
-1 
（1000 0001）原碼
（1111 1110）反碼
（1111 1111）補碼
求（1111 1111）補碼表示的原碼。
（1111 1111）補碼
（1000 0000）反碼
（1000 0001）原碼

例2：
由上面可知 -1 的補碼是 1111 1111，求 1111 1111 補碼的相反數。
（1111 1111）補碼
（0000 0000）取反
（0000 0001）+1

### 原碼和反碼的0都有兩種表示
+0 = 0000 0001
-0 = 1000 0001
因此原碼和反碼表示的範圍都是是-127 ~ +127。
**但補碼的0只有一種表示，即 0000 0000。那麼補碼的表示範圍是-128 ~ +127**
當時本人一直是沒想明白：為什麼可以表示多一位，而且還是-128。
於是找到以下答案：
既然補碼表示0的是 0000 0000 那麼就多出一位，即: 1000 0000。其實這是一個規定， 這個補碼表示的是 -128。況且[1000 0000]也沒有相對應的原碼。

### 舉個栗子

+100 0110(正數)
原碼: 0100 0110
反碼: 0100 0110
補碼: 0100 0110

-100 0110(負數)
原碼： 1100 0110
反碼： 1011 1001
補碼： 1011 1010

## 4.幾個特殊定義：
(1): n位補碼能表示的範圍：有符號數是 -2^(n-1) 到 2^(n-1)-1。無符號是 0 到 2^(n-1)。
(2): -128 的補碼是 1000 0000, -128 + 1 = -127，(-127)補 = 1000 0001 = 1000 0000 + 0000 0001 符合運算規則。
(3): 0 的補碼 0000 0000

## 既然學會了原碼和補碼就可以解釋一下以前遇到有趣的代碼
其實也沒有學會，因為原碼、反碼和補碼都有公式。反正我是沒看明白。以前老師也沒講公式上來就是說：原碼符號位0表示正，1表示負。反碼就是除了符號位不變， 1變0,0變1。補碼就是反碼+1。

### 疑惑
本人學C語言是看書入門的， c primer plus是一本很好的入門書。書中第六章的“6.2.1 終止 while 循環”有個問題就是一個變量自減特定次后會從負數變成正數，讓後終止循環。
![c primer plus](http://opkl2tvjd.bkt.clouddn.com/while.png "while")
測試了一下， 果真如此。代碼如下：
``` c
    // while.c
    #include <stdio.h>
    int main(void)
    {
        signed char index = 1;      // 使用 char ， 使用其它整數類型迭代次數較多。

        while (--index < 5)
            printf("%d ", index);
        printf("\n\nlast value: %d\n", index);

        return 0;
    }
```
輸出如下：
![program](http://opkl2tvjd.bkt.clouddn.com/while2.png "while test")
**很明顯迭代的退出`index`的值是 127。 127 < 5 表達式的值為0。`signed char`一字節（八位），從左往右第一位是符號位。負數用補碼存儲。範圍是 -2^(8-1) ~ 2^(8-1)-1， 即 -128 ~ 127。**
很好， 有點眉頭了。

## 溢出
下面我們來看一段代碼:
``` c
    // limit.c
    #include <stdio.h>
    int main(void)
    {
        signed char num = -1;
        printf("signed: %hhd, unsigned: %hhu\n", num, num);

        return 0;
    }
```
輸出如下：
![limit](http://opkl2tvjd.bkt.clouddn.com/limit1.png "ByXc")
由例1已知， -1 的補碼是 1111 1111。如果是按有符號解析的話，第一位是符號位（為負），其餘是數值位。所以正是-1。但如果是無符號為的話，八位全是數值位，即是255。
還沒完咧， 繼續往下看：
``` c
    // limit2.c
    #include <stdio.h>
    #include <limits.h>     // 提供明示常量

    #define UCHAR_MIN 0     // 因為無符號最小值就是0， limits.h 頭文件里沒有
    #define UINT_MIN 0

    int main(void)
    {
        printf("UCHAR_MAX = %hhu, UCHAR_MAX + 1 = %hhu\n", UCHAR_MAX, UCHAR_MAX + 1);
        printf("UCHAR_MIN = %hhu, UCHAR_MIN - 1 = %hhu\n", UCHAR_MIN, UCHAR_MIN - 1);
        printf("CHAR_MAX = %hhd, CHAR_MAX + 1 = %hhd\n", CHAR_MAX, CHAR_MAX + 1);
        printf("CHAR_MIN = %hhd, CHAR_MIN - 1 = %hhd\n", CHAR_MIN, CHAR_MIN - 1);
        putchar('\n');

        printf("UINT_MAX = %u, UINT_MAX + 1 = %u\n", UINT_MAX, UINT_MAX + 1);
        printf("UINT_MIN = %u, UINT_MIN - 1 = %u\n", UINT_MIN, UINT_MIN - 1);
        printf("INT_MAX = %d, INT_MAX + 1 = %d\n", INT_MAX, INT_MAX + 1);
        printf("INT_MIN = %d, INT_MIN - 1 = %d\n", INT_MIN, INT_MAX - 1);

        return 0;
    }
```
輸出以下：
![limit2](http://opkl2tvjd.bkt.clouddn.com/limit2.png "ByXc")
好吧，終於警告了。
我只把`char`類型的解釋一下， 其它的整數類型也一樣，就不作重複解釋了。以下是本人的瞎解釋，歡迎指出錯誤。

**1.正溢出。 八位無符號最大值是255。**
      1111 1111 [+255]
\+    0000 0001 [+1]
= (1) 0000 0000 [0]
符號位溢出。

**2.負溢出。八位無符號。**
     0000 0000 [0]
\-    0000 0001 [1]
=    1111 1111 [+255]

**3.正溢出。有符號八位最大值是127。**
   0111 1111 [+127]
\+ 0000 0001 [+1]
=  1000 0000 (補碼）[-128]
符號位溢出

**4.負溢出。有符號八位最小值是-128。補碼為: 1000 0000。**
   1000 0000 （補碼)[-128]
\-  0000 0001 [+1]
=  0111 1111 [+127]


postscript:以上的代碼輸出可能不是所有的機器上都是一樣。因為本人剛看到了十五章，將現所學的進行解答。

## 最後
唉，不說了， 繼續研究二進制浮點數。
